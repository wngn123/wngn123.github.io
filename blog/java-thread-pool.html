<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java线程 ThreadPoolExecutor|wngn123-GitBlog</title>
	<meta name="keywords" content="java,Java,wngn123-GitBlog">
	<meta name="description" content="阅读Java的源码，Java线程，ThreadPoolExecutor">
	
	<link rel="stylesheet" href="/theme/quest/assets/plugins/bootstrap/css/bootstrap.min.css?ver=2.1" type="text/css" media="all" />
	<link rel="stylesheet" href="/theme/quest/assets/plugins/font-awesome/css/font-awesome.min.css?ver=2.1" type="text/css" media="all" />
	<link rel="stylesheet" href="/theme/quest/css/style.css?ver=2.1" type="text/css" media="all" />
	<link rel="stylesheet" href="/theme/quest/css/customizer.css?ver=2.1" type="text/css" media="all" />
	<link rel="alternate" type="application/rss+xml" title="wngn123-GitBlog" href="//feed.xml" />
	
	</head>

<body class="home blog wide">
	<div id="page" class="hfeed site">
		<a class="skip-link screen-reader-text" href="#content">Skip to content</a>
		    <header id="masthead" class="main-header" role="banner">
<div class="container">
	<div class="row">
		<div class="site-branding col-md-4">
			<h1 class="site-title"><a href="/" rel="home">wngn123-GitBlog</a></h1>
				<span class="site-description">GitBlog</span>
		</div>
		<!-- .site-branding -->
	</div>
</div>
</header>		    <div id="content">
	<div class="quest-row site-content">
		<div class="container">
			<div class="row">
				<div id="primary" class="content-area single col-md-9">
					<div id="main" class="site-main" role="main">
						<article class="post hentry">
	<header class="entry-header">
	<h1 class="post-title"><a href="/blog/java-thread-pool.html" rel="bookmark">Java线程 ThreadPoolExecutor</a></h1>
	<div class="entry-meta">
		<time class="post-date"><i class="fa fa-clock-o"></i>2016-09-13</time>
				<span class="seperator">/</span>
	    <span><i class="fa fa-user"></i> wngn123</span>
	    	</div><!-- .entry-meta -->
</header><!-- .entry-header -->	<div class="entry-content">
	<p>
		<!--
author: wngn123
head: head.png
date: 2016-09-13
title: Java线程 ThreadPoolExecutor
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Java线程，ThreadPoolExecutor
-->
<h2>Executor接口</h2>
<p>执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。例如，可能会使用以下方法，而不是为一组任务中的每个任务调用 <code>new Thread(new(RunnableTask())).start()</code>： </p>
<pre><code> Executor executor = anExecutor;
 executor.execute(new RunnableTask1());
 executor.execute(new RunnableTask2());
 ...</code></pre>
<p>不过，Executor 接口并没有严格地要求执行是异步的。在最简单的情况下，执行程序可以在调用者的线程中立即运行已提交的任务： </p>
<pre><code> class DirectExecutor implements Executor {
     public void execute(Runnable r) {
         r.run();
     }
 }</code></pre>
<p>更常见的是，任务是在某个不是调用者线程的线程中执行的。以下执行程序将为每个任务生成一个新线程。 </p>
<pre><code> class ThreadPerTaskExecutor implements Executor {
     public void execute(Runnable r) {
         new Thread(r).start();
     }
 }</code></pre>
<p>许多 Executor 实现都对调度任务的方式和时间强加了某种限制。以下执行程序使任务提交与第二个执行程序保持连续，这说明了一个复合执行程序。 </p>
<pre><code> class SerialExecutor implements Executor {
     final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();
     final Executor executor;
     Runnable active;

     SerialExecutor(Executor executor) {
         this.executor = executor;
     }

     public synchronized void execute(final Runnable r) {
         tasks.offer(new Runnable() {
             public void run() {
                 try {
                     r.run();
                 } finally {
                     scheduleNext();
                 }
             }
         });
         if (active == null) {
             scheduleNext();
         }
     }

     protected synchronized void scheduleNext() {
         if ((active = tasks.poll()) != null) {
             executor.execute(active);
         }
     }
 }</code></pre>
<p>此包中提供的 Executor 实现实现了 ExecutorService，这是一个使用更广泛的接口。ThreadPoolExecutor 类提供一个可扩展的线程池实现。Executors 类为这些 Executor 提供了便捷的工厂方法。
内存一致性效果：线程中将 Runnable 对象提交到 Executor 之前的操作 happen-before 其执行开始（可能在另一个线程中）。 </p>
<pre><code>public interface Executor {
    //在未来某个时间执行给定的命令
    void execute(Runnable command);
}
</code></pre>
<h2>ExecutorService接口</h2>
<p>Executor 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 </p>
<p>可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。<code>shutdown()</code> 方法在终止前允许执行以前提交的任务，而 <code>shutdownNow()</code> 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。 </p>
<p>通过创建并返回一个可用于取消执行和/或等待完成的 <code>Future</code>，方法 <code>submit</code> 扩展了基本方法<code>Executor.execute(java.lang.Runnable)</code>。方法 <code>invokeAny</code> 和 <code>invokeAll</code> 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成（可使用 <code>ExecutorCompletionService</code> 类来编写这些方法的自定义变体）。 </p>
<p>Executors 类提供了用于此包中所提供的执行程序服务的工厂方法。 </p>
<pre><code>shutdown()
shutdownNow()
isShutdown()
isTerminated()
awaitTermination(long, TimeUnit)
submit(Callable&lt;T&gt;)
submit(Runnable, T)
submit(Runnable)
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;)
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;, long, TimeUnit)
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt;)
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt;, long, TimeUnit)</code></pre>
<pre><code>public interface ExecutorService extends Executor {
    //启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 
    void shutdown();

    /**
     * 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。
     * 无法保证能够停止正在处理的活动执行任务，但是会尽力尝试。
     * 例如，通过 Thread.interrupt() 来取消典型的实现，所以任何任务无法响应中断都可能永远无法终止
     */
    List&lt;Runnable&gt; shutdownNow();

    //如果此执行程序已关闭，则返回 true
    boolean isShutdown();

    //如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。 
    boolean isTerminated();

    /**
     * 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。
     * @param timeout 最长等待时间
     * @param unit timeout参数的时间单位
     * @return 如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false 
     */
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回该任务的结果。 
     * 如果想立即阻塞任务的等待，则可以使用 result = exec.submit(aCallable).get(); 形式的构造。
     */ 
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回给定的结果。 
     */
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回 null。 
     */
    Future&lt;?&gt; submit(Runnable task);

    /**
     * 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。
     * 返回列表的所有元素的 Future.isDone() 为 true。
     * 注意，可以正常地或通过抛出异常来终止已完成 任务。如果正在进行此操作时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;

    /**
     * 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。
     * 返回列表的所有元素的 Future.isDone() 为 true。一旦返回后，即取消尚未完成的任务。
     * 注意，可以正常地或通过抛出异常来终止已完成 任务。如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的
     */
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
     * 如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;

    /**
     * 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
     * 如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<h2>AbstractExecutorService抽象类</h2>
<p>提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。例如，submit(Runnable) 的实现创建了一个关联 RunnableFuture 类，该类将被执行并返回。子类可以重写 newTaskFor 方法，以返回 FutureTask 之外的 RunnableFuture 实现。</p>
<pre><code>doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt;, boolean, long)
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;)
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt;, long, TimeUnit)
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt;)
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt;, long, TimeUnit)
newTaskFor(Runnable, T)
newTaskFor(Callable&lt;T&gt;)
submit(Runnable)
submit(Runnable, T)
submit(Callable&lt;T&gt;)</code></pre>
<pre><code>package java.util.concurrent;
import java.util.*;

public abstract class AbstractExecutorService implements ExecutorService {

    /**
     * 为给定可运行任务和默认值返回一个 RunnableFuture。
     * @param runnable 将被包装的可运行任务
     * @param value 用于所返回的将来任务的默认值
     * @return a RunnableFuture，在运行的时候，它将运行底层可运行任务，作为 Future 任务，它将生成给定值作为其结果，并为底层任务提供取消操作。
     */
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }

    /**
     * 为给定可调用任务返回一个 RunnableFuture。 
     * @param callable 将包装的可调用任务 
     */
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回给定的结果。 
     */
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    /**
     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回该任务的结果。 
     * 如果想立即阻塞任务的等待，则可以使用 result = exec.submit(aCallable).get(); 形式的构造。
     */
    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                            boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
        if (tasks == null)
            throw new NullPointerException();
        int ntasks = tasks.size();
        if (ntasks == 0)
            throw new IllegalArgumentException();
        List&lt;Future&lt;T&gt;&gt; futures= new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);
        ExecutorCompletionService&lt;T&gt; ecs =
            new ExecutorCompletionService&lt;T&gt;(this);

        // For efficiency, especially in executors with limited
        // parallelism, check to see if previously submitted tasks are
        // done before submitting more of them. This interleaving
        // plus the exception mechanics account for messiness of main
        // loop.

        try {
            // Record exceptions so that if we fail to obtain any
            // result, we can throw the last exception we got.
            ExecutionException ee = null;
            long lastTime = timed ? System.nanoTime() : 0;
            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();

            // Start one task for sure; the rest incrementally
            futures.add(ecs.submit(it.next()));
            --ntasks;
            int active = 1;

            for (;;) {
                Future&lt;T&gt; f = ecs.poll();
                if (f == null) {
                    if (ntasks &gt; 0) {
                        --ntasks;
                        futures.add(ecs.submit(it.next()));
                        ++active;
                    }
                    else if (active == 0)
                        break;
                    else if (timed) {
                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                        if (f == null)
                            throw new TimeoutException();
                        long now = System.nanoTime();
                        nanos -= now - lastTime;
                        lastTime = now;
                    }
                    else
                        f = ecs.take();
                }
                if (f != null) {
                    --active;
                    try {
                        return f.get();
                    } catch (ExecutionException eex) {
                        ee = eex;
                    } catch (RuntimeException rex) {
                        ee = new ExecutionException(rex);
                    }
                }
            }

            if (ee == null)
                ee = new ExecutionException();
            throw ee;

        } finally {
            for (Future&lt;T&gt; f : futures)
                f.cancel(true);
        }
    }

    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException, ExecutionException {
        try {
            return doInvokeAny(tasks, false, 0);
        } catch (TimeoutException cannotHappen) {
            assert false;
            return null;
        }
    }

    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        return doInvokeAny(tasks, true, unit.toNanos(timeout));
    }

    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());
        boolean done = false;
        try {
            for (Callable&lt;T&gt; t : tasks) {
                RunnableFuture&lt;T&gt; f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (Future&lt;T&gt; f : futures) {
                if (!f.isDone()) {
                    try {
                        f.get();
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (Future&lt;T&gt; f : futures)
                    f.cancel(true);
        }
    }

    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        if (tasks == null || unit == null)
            throw new NullPointerException();
        long nanos = unit.toNanos(timeout);
        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());
        boolean done = false;
        try {
            for (Callable&lt;T&gt; t : tasks)
                futures.add(newTaskFor(t));

            long lastTime = System.nanoTime();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();
            while (it.hasNext()) {
                execute((Runnable)(it.next()));
                long now = System.nanoTime();
                nanos -= now - lastTime;
                lastTime = now;
                if (nanos &lt;= 0)
                    return futures;
            }

            for (Future&lt;T&gt; f : futures) {
                if (!f.isDone()) {
                    if (nanos &lt;= 0)
                        return futures;
                    try {
                        f.get(nanos, TimeUnit.NANOSECONDS);
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    } catch (TimeoutException toe) {
                        return futures;
                    }
                    long now = System.nanoTime();
                    nanos -= now - lastTime;
                    lastTime = now;
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (Future&lt;T&gt; f : futures)
                    f.cancel(true);
        }
    }

}
</code></pre>
<h2>AtomicInteger原子操作int</h2>
<p>可以用原子方式更新的 int 值。AtomicInteger 可用在应用程序中（如以原子方式增加的计数器），并且不能用于替换 Integer。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 </p>
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    static {
      try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
      } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }
    public AtomicInteger() {
    }
    public final int get() {
        return value;
    }
    public final void set(int newValue) {
        value = newValue;
    }

    /**
     * 最后设置为给定值
     */
    public final void lazySet(int newValue) {
        unsafe.putOrderedInt(this, valueOffset, newValue);
    }

    /**
     * 以原子方式设置为给定值，并返回旧值。
     */
    public final int getAndSet(int newValue) {
        for (;;) {
            int current = get();
            if (compareAndSet(current, newValue))
                return current;
        }
    }

    /**
     * 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值
     */
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    /**
     * 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。
     */
    public final boolean weakCompareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    /**
     * 以原子方式将当前值加 1。
     */
    public final int getAndIncrement() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将当前值减 1。
     */
    public final int getAndDecrement() {
        for (;;) {
            int current = get();
            int next = current - 1;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将给定值与当前值相加
     */
    public final int getAndAdd(int delta) {
        for (;;) {
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将当前值加 1。
     */
    public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

    /**
     * 以原子方式将当前值减 1。
     */
    public final int decrementAndGet() {
        for (;;) {
            int current = get();
            int next = current - 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

    /**
     * 以原子方式将给定值与当前值相加。
     */
    public final int addAndGet(int delta) {
        for (;;) {
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return next;
        }
    }

    public String toString() {
        return Integer.toString(get());
    }

    public int intValue() {
        return get();
    }

    public long longValue() {
        return (long)get();
    }

    public float floatValue() {
        return (float)get();
    }

    public double doubleValue() {
        return (double)get();
    }

}
</code></pre>
<h2>ThreadPoolExecutor</h2>
<p>一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 </p>
<p>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 </p>
<p>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 <code>Executors.newCachedThreadPool()</code>（无界线程池，可以进行自动线程回收）、<code>Executors.newFixedThreadPool(int)</code>（固定大小线程池）和 <code>Executors.newSingleThreadExecutor()</code>（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时，使用以下指导： </p>
<h4>核心和最大池大小</h4>
<p>ThreadPoolExecutor 将根据 corePoolSize 和 maximumPoolSize 设置的边界自动调整池大小。当新任务在方法 <code>execute(java.lang.Runnable)</code> 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用 <code>setCorePoolSize(int)</code> 和 <code>setMaximumPoolSize(int)</code> 进行动态更改。 </p>
<h4>按需构造</h4>
<p>默认情况下，即使核心线程最初只是在新任务到达时才创建和启动的，也可以使用方法 <code>prestartCoreThread()</code> 或 <code>prestartAllCoreThreads()</code> 对其进行动态重写。如果构造带有非空队列的池，则可能希望预先启动线程。 </p>
<h4>创建新线程</h4>
<p>使用 ThreadFactory 创建新线程。如果没有另外说明，则在同一个 ThreadGroup 中一律使用 <code>Executors.defaultThreadFactory()</code> 创建线程，并且这些线程具有相同的 NORM_PRIORITY 优先级和非守护进程状态。通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态，等等。如果从 newThread 返回 null 时 ThreadFactory 未能创建线程，则执行程序将继续运行，但不能执行任何任务。 </p>
<h4>保持活动时间</h4>
<p>如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止。这提供了当池处于非活动状态时减少资源消耗的方法。如果池后来变得更为活动，则可以创建新的线程。也可以使用方法 <code>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</code> 动态地更改此参数。使用 <code>Long.MAX_VALUE</code> <code>TimeUnit.NANOSECONDS</code>的值在关闭前有效地从以前的终止状态禁用空闲线程。默认情况下，保持活动策略只在有多于 corePoolSizeThreads 的线程时应用。但是只要 keepAliveTime 值非 0，<code>allowCoreThreadTimeOut(boolean)</code> 方法也可将此超时策略应用于核心线程。 </p>
<h4>排队</h4>
<p>所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互： </p>
<ul>
<li>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。 </li>
<li>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。 </li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。 </li>
</ul>
<p>排队有三种通用策略： </p>
<ul>
<li>直接提交： 工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 </li>
<li>无界队列： 使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 </li>
<li>有界队列： 当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </li>
</ul>
<h4>被拒绝的任务</h4>
<p>当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 <code>execute(java.lang.Runnable)</code> 中提交的新任务将被拒绝。在以上两种情况下，execute 方法都将调用其 RejectedExecutionHandler 的 <code>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</code> 方法。下面提供了四种预定义的处理程序策略： </p>
<ul>
<li>在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时 RejectedExecutionException。 </li>
<li>在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 </li>
<li>在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。 </li>
<li>在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。 </li>
</ul>
<p>定义和使用其他种类的 RejectedExecutionHandler 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。 </p>
<h4>钩子 (hook) 方法</h4>
<p>此类提供 protected 可重写的 beforeExecute(java.lang.Thread, java.lang.Runnable) 和 afterExecute(java.lang.Runnable, java.lang.Throwable) 方法，这两种方法分别在执行每个任务之前和之后调用。它们可用于操纵执行环境；例如，重新初始化 ThreadLocal、搜集统计信息或添加日志条目。此外，还可以重写方法 terminated() 来执行 Executor 完全终止后需要完成的所有特殊处理。 </p>
<p>如果钩子 (hook) 或回调方法抛出异常，则内部辅助线程将依次失败并突然终止。 </p>
<h4>队列维护</h4>
<p>方法 getQueue() 允许出于监控和调试目的而访问工作队列。强烈反对出于其他任何目的而使用此方法。    <code>remove(java.lang.Runnable)</code> 和 <code>purge()</code> 这两种方法可用于在取消大量已排队任务时帮助进行存储回收。 </p>
<h4>终止</h4>
<p>程序 AND 不再引用的池没有剩余线程会自动 shutdown。如果希望确保回收取消引用的池（即使用户忘记调用 shutdown()），则必须安排未使用的线程最终终止：设置适当保持活动时间，使用 0 核心线程的下边界和/或设置   <code>allowCoreThreadTimeOut(boolean)</code>   </p>
<pre><code>   // 1110 0000 0000 0000 0000 0000 0000 0000 | -536870912
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // Integer.SIZE=32  | COUNT_BITS = 29 | 11101
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 1 &lt;&lt; COUNT_BITS = 10 0000 0000 0000 0000 0000 0000 0000 | 536870912 
    // CAPACITY=1 1111  1111 1111 1111 1111 1111 1111=536870911 
    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    // -1 = 1111 1111 1111 1111 1111 1111 1111 1111
    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;//11100000000000000000000000000000|-536870912
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;//0
    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;//100000000000000000000000000000 | 536870912
    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;//1000000000000000000000000000000| 1073741824
    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;//1100000000000000000000000000000| 1610612736
</code></pre>
<pre><code>    // Packing and unpacking ctl 打包和拆包CTL
    //c &amp; 1110 0000 0000 0000 0000 0000 0000 0000 |取高3位 | &amp;与遇0为0，同1为1
    private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
    // c &amp; 1 1111 1111 1111 1111 1111 1111 1111 | 取地位 |
    private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }</code></pre>
<pre><code>    /*
     * Bit field accessors that don't require unpacking ctl.
     * These depend on the bit layout and on workerCount being never negative.
     * 位字段访问不需要拆包CTL。
     * 这取决于位布局和workerCount是永远不会为负。
     */

    private static boolean runStateLessThan(int c, int s) {
        return c &lt; s;
    }

    private static boolean runStateAtLeast(int c, int s) {
        return c &gt;= s;
    }

    private static boolean isRunning(int c) {
        return c &lt; SHUTDOWN;
    }
</code></pre>
<pre><code>     /**
     * Attempt to CAS-increment the workerCount field of ctl.
     * 预期值加1
     */
    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    /**
     * Attempt to CAS-decrement the workerCount field of ctl.
     * 预期值减1
     */
    private boolean compareAndDecrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect - 1);
    }

    /**
     * Decrements the workerCount field of ctl. This is called only on
     * abrupt termination of a thread (see processWorkerExit). Other
     * decrements are performed within getTask.
     */
    private void decrementWorkerCount() {
        do {} while (! compareAndDecrementWorkerCount(ctl.get()));
    }</code></pre>
<pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;
private final ReentrantLock mainLock = new ReentrantLock();
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
private final Condition termination = mainLock.newCondition();
private int largestPoolSize;
private long completedTaskCount;
private volatile ThreadFactory threadFactory;
private volatile RejectedExecutionHandler handler;
private volatile long keepAliveTime;
private volatile boolean allowCoreThreadTimeOut;
private volatile int corePoolSize;
private volatile int maximumPoolSize;
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
private static final RuntimePermission shutdownPerm =  new RuntimePermission("modifyThread");</code></pre>
<pre><code>
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock() {
            acquire(1);
        }

        public boolean tryLock() {
            return tryAcquire(1);
        }

        public void unlock() {
            release(1);
        }

        public boolean isLocked() {
            return isHeldExclusively();
        }

        void interruptIfStarted() {
            Thread t;
            if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }</code></pre>
<h2>ThreadPoolExecutor构造函数</h2>
<p><code>corePoolSize：</code>核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
<p><code>maximumPoolSize：</code>线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
<p><code>keepAliveTime：</code>表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
<p><code>unit：</code>参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<pre><code>TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒</code></pre>
<p><code>workQueue：</code>一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<pre><code>ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;</code></pre>
<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
<p><code>threadFactory：</code>线程工厂，主要用来创建线程；</p>
<p><code>handler：</code>表示当拒绝处理任务时的策略，有以下四种取值：</p>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </code></pre>
<pre><code>    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     *        线程池中维持的线程数量，即使他们是空闲线程，除非allowCoreThreadTimeOut被设置
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool 线程池允许存在的最大线程数量
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     *        当线程池当前线程数量超过最大线程数量时，空闲线程等待新任务的最大时间
     * @param unit the time unit for the {@code keepAliveTime} argument 时间单位参数
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
     *         {@code corePoolSize &lt; 0}&lt;br&gt;
     *         {@code keepAliveTime &lt; 0}&lt;br&gt;
     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;
     *         {@code maximumPoolSize &lt; corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize &lt; 0 ||
            maximumPoolSize &lt;= 0 ||
            maximumPoolSize &lt; corePoolSize ||
            keepAliveTime &lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }</code></pre>
<pre><code>    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }</code></pre>
<h2>ThreadPoolExecutor线程池状态</h2>
<ul>
<li><strong> RUNNING </strong>  运行状态：-1</li>
<li><strong> SHUTDOWN </strong> 停工状态：0</li>
<li><strong> STOP </strong>     停止状态：1</li>
<li><strong> TIDYING </strong>  整理状态：2</li>
<li><strong> TERMINATED </strong> 结束状态：3</li>
</ul>
<h4>状态描述</h4>
<p><code>RUNNING:</code>Accept new tasks and process queued tasks </p>
<p>接受新的任务和进程排队任务</p>
<p><code>SHUTDOWN:</code>Don't accept new tasks, but process queued tasks </p>
<p>不要接受新的任务，但进程排队任务</p>
<p><code>STOP:</code>Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks </p>
<p>不要接受新的任务，不处理排队任务，中断正在进行的任务</p>
<p><code>TIDYING:</code>All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method </p>
<p>所有任务已终止，workerCount为零，线程转换到TIDYING（整理）状态将运行terminated()挂钩方法</p>
<p><code>TERMINATED:</code>terminated() has completed
terminated（）方法已完成</p>
<h4>状态转换</h4>
<p><code>RUNNING -&gt; SHUTDOWN</code> 调用shutdown(), 也许隐含在finalize（）</p>
<p><code>(RUNNING or SHUTDOWN) -&gt; STOP</code> 调用shutdownNow()</p>
<p><code>SHUTDOWN -&gt; TIDYING</code> When both queue and pool are empty</p>
<p><code>STOP -&gt; TIDYING</code> When pool is empty</p>
<p><code>TIDYING -&gt; TERMINATED</code> When the terminated() hook method has completed</p>
<pre><code>    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></pre>
<ul>
<li>当创建线程池后，初始时，线程池处于RUNNING状态；</li>
<li>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</li>
</ul>
<h2>execute提交任务</h2>
<p><code>void execute(Runnable command)</code></p>
<p>执行给定的任务，不会立即执行</p>
<p>如果少于corePoolSize线程正在运行，尝试启动一个新的线程并使用给定的任务作为他的第一个任务。
调用addWorker呼叫原子检查runState和workerCount，以防止误报警（将当它不能添加线程，返回false）</p>
<p>如果任务被成功的添加到任务队列，然后我们任需要双重检测是否我们可以添加线程（因为上次检测存在的线程可能会死去）或者线程池在我们进入该方法时线程池已经关闭。因此我们重新检测状态，并在必要时回滚如果停止或启动一个新的线程如果有没有入队。</p>
<p>如果我们不能排队的任务，那么我们尝试添加一个新的线程。如果失败，我们知道我们正在关闭或饱和，所以拒绝的任务。</p>
<pre><code>    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();//初始值为0
        //workerCountOf(0) = 0
        //如果当前线程数量小于corePoolSize，创建线程
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
</code></pre>
<h4>workerCountOf</h4>
<pre><code>// c &amp; 0001 1111 1111 1111 1111 1111 1111 1111 | 遇0为0
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }</code></pre>
<h4>addWorker</h4>
<p><code>firstTask</code> the task the new thread should run first (or null if none). Workers are created with an initial first task (in method execute()) to bypass queuing when there are fewer than corePoolSize threads (in which case we always start one), or when the queue is full (in which case we must bypass queue).  Initially idle threads are usually created via prestartCoreThread or to replace other dying workers.</p>
<p><code>core</code> if true use corePoolSize as bound, else</p>
<p><code>retry:</code>标志符 指出下面语句从哪里开始执行 你代码里面有continue retry; 也就是说下面从 retry: 这里继续执行</p>
<pre><code>    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) { //死循环
            int c = ctl.get();
            int rs = runStateOf(c);
            //获取当前线程池的状态，如果是STOP，TIDYING,TERMINATED状态的话，则会返回false，
            //如果现在状态是SHUTDOWN，但是firstTask不为空或者workQueue为空的话，那么直接返回false。
            // Check if queue empty only if necessary.
            if (rs &gt;= SHUTDOWN &amp;&amp; 
                ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty()))
                return false;
            //通过自旋的方式，判断要添加的Worker是否是corePool，
            //如果是的话，那么则判断当前的workerCount是否大于corePoolsize，否则则判断是否大于maximumPoolSize，
            //如果满足的话，说明workerCount超出了线程池大小，直接返回false。
            //如果小于的话，那么判断是否成功将WorkerCount通过CAS操作增加1，
            //如果增加成功的话。则进行到第3步，否则则判断当前线程池的状态，
            //如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue retry重新进行状态的判断
            for (;;) {
                int wc = workerCountOf(c);//当前线程数量
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))//线程数加1
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
        //如果满足了的话，那么则创建一个新的Worker对象，
        //然后获取线程池的重入锁后，判断当前线程池的状态，
        //如果当前线程池状态为STOP,TIDYING,TERMINATED的话，
        //那么调用decrementWorkerCount将workerCount减一，
        //然后调用tryTerminate停止线程池，并且返回false。
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            final ReentrantLock mainLock = this.mainLock;
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();
                    int rs = runStateOf(c);

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                      //如果状态满足的话，那么则在workers中将新创建的worker添加，
                     //并且重新计算largestPoolSize，然后启动Worker中的线程开始执行任务。
                        workers.add(w);
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
</code></pre>
<pre><code>    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }</code></pre>
		</p>
</div><!-- .entry-content -->	<footer class="entry-footer">
		<ul class="post-categories">
          
          <li><a href="/category/3803722005.html" rel="category">Java</a></li>
        	</ul>
		
		<ul class="post-tags">
                   <li><a href="/tags/3692263176.html" rel="tag">java</a></li>
        	</ul>
		
	</footer><!-- .entry-footer --></article><!-- #post-## -->            								</div>
					<!-- #main -->
				</div>
				<!-- #primary -->
				<div id="secondary" class="widget-area main-sidebar col-md-3" role="complementary">
	<aside class="widget widget_categories sidebar-widget clearfix">
	<h3 class="widget-title">分类目录</h3>
	<ul>
		        <li class="cat-item"><a href="/category/107260689.html" >GitBlog</a></li>
                <li class="cat-item"><a href="/category/1769324555.html" >HTTPS</a></li>
                <li class="cat-item"><a href="/category/3803722005.html" >Java</a></li>
                <li class="cat-item"><a href="/category/1914056710.html" >Lua</a></li>
                <li class="cat-item"><a href="/category/505585837.html" >Other</a></li>
                <li class="cat-item"><a href="/category/26890208.html" >PHP</a></li>
                <li class="cat-item"><a href="/category/3026742571.html" >Centos</a></li>
        	</ul>
</aside>
	<aside class="widget widget_archive sidebar-widget clearfix">
	<h3 class="widget-title">文章归档</h3>
	<ul>
		<li><a href="/archive/201608.html">2016-08</a></li>
		<li><a href="/archive/201507.html">2015-07</a></li>
		<li><a href="/archive/201609.html">2016-09</a></li>
		</ul>
</aside>	<aside class="widget widget_recent_entries sidebar-widget clearfix">
	<h3 class="widget-title">近期文章</h3>
	<ul>
	    <li><a href="/blog/java-jvm-jmap.html">JVM工具 jmap</a></li>
        <li><a href="/blog/java-jvm-jstack.html">JVM工具 jstack</a></li>
        <li><a href="/blog/java-jvm-jstat.html">JVM工具 jstat</a></li>
        <li><a href="/blog/java-jvm-jps.html">JVM工具 jps</a></li>
        <li><a href="/blog/java-thread-pool.html">Java线程 ThreadPoolExecutor</a></li>
    	</ul>
</aside>
	<aside class="widget widget_tag_cloud sidebar-widget clearfix">
	<h3 class="widget-title">标签</h3>
	<div class="tagcloud">
		<a href="/tags/2511338272.html"  title="git" >git</a>
		<a href="/tags/2013555047.html"  title="blog" >blog</a>
		<a href="/tags/2278070035.html"  title="keytool" >keytool</a>
		<a href="/tags/3635419366.html"  title="https" >https</a>
		<a href="/tags/3692263176.html"  title="java" >java</a>
		<a href="/tags/3943951533.html"  title="ssl" >ssl</a>
		<a href="/tags/915562279.html"  title="client" >client</a>
		<a href="/tags/1386710576.html"  title="lua" >lua</a>
		<a href="/tags/474222454.html"  title="markdown" >markdown</a>
		<a href="/tags/1783669539.html"  title="php" >php</a>
		<a href="/tags/1845431629.html"  title="php5" >php5</a>
		<a href="/tags/367908174.html"  title="php7" >php7</a>
		<a href="/tags/1334393457.html"  title="centos" >centos</a>
		<a href="/tags/3084495193.html"  title="centos6" >centos6</a>
		<a href="/tags/1155787600.html"  title="linux" >linux</a>
		<a href="/tags/3602381148.html"  title="jvm" >jvm</a>
		<a href="/tags/1713449722.html"  title="jmap" >jmap</a>
		<a href="/tags/1250710160.html"  title="jps" >jps</a>
		<a href="/tags/2437014784.html"  title="jstack" >jstack</a>
		<a href="/tags/3360952118.html"  title="jstat" >jstat</a>
		</div>
</aside>
	<aside class="widget widget_text sidebar-widget clearfix">
	<h3 class="widget-title">介绍</h3>
	<div class="textwidget">
		<p>本博客使用Gitblog搭建，欢迎你!</p>
	</div>
</aside>
</div><!-- #secondary -->			</div>
			<!-- .row -->
		</div>
		<!-- .container -->
	</div>
	<!-- .quest-row -->
</div>		    <footer id="colophon" class="copyright quest-row" role="contentinfo">
	<div class="container">
		<div class="row">
			<div class="col-md-6 copyright-text">
				<a href="https://github.com/jockchou/gitblog">Proudly powered by Gitblog</a>
			</div>
			<div class="col-md-6 social-icon-container clearfix">
				<ul></ul>
			</div>
		</div>
		<!-- end row -->
	</div>
	<!-- end container -->
</footer>	</div><!-- #page -->
	<a href="#0" class="cd-top"><i class="fa fa-angle-up"></i></a>


<script type="text/javascript" src="/theme/quest/assets/plugins/modernizr/modernizr.custom.js?ver=2.1"></script>
<script type="text/javascript" src="/theme/quest/js/jquery/jquery.js?ver=1.11.2"></script>
<script type="text/javascript" src="/theme/quest/js/jquery/jquery-migrate.min.js?ver=1.2.1"></script>
<script type="text/javascript" src="/theme/quest/assets/plugins/bootstrap/js/bootstrap.min.js?ver=2.1"></script>
<script type="text/javascript" src="/theme/quest/assets/plugins/wow/wow.js?ver=2.1"></script>
<script type="text/javascript" src="/theme/quest/assets/plugins/colorbox/jquery.colorbox-min.js?ver=2.1"></script>
<script type="text/javascript" src="/theme/quest/assets/js/quest.js?ver=2.1"></script>
	
<link rel="stylesheet" href="http://cdn.bootcss.com/highlight.js/8.6/styles/default.min.css">
<script src="http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>