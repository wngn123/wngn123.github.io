<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>wngn123-GitBlog</title>
        <description>GitBlog是一个简单易用的Markdown博客系统</description>
        <link>/</link>
        <atom:link href="//feed.xml" rel="self" type="application/rss+xml" />
        <pubDate>2016-09-13 15:09:33</pubDate>
        <lastBuildDate>2016-09-13 15:09:33</lastBuildDate>
        <generator>Gitblog v1.0</generator>
                <item>
            <title>JVM工具 jmap</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-13
title: JVM工具 jmap
tags: java jvm jmap
category: Java
status: publish
summary: JVM工具 jmap
--&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。&lt;/p&gt;
&lt;p&gt;可以输出所有内存中对象的工具，甚至可以将JVM中的heap，以二进制输出成文本。使用方法&lt;code&gt;jmap -histo pid&lt;/code&gt;。如果连用&lt;code&gt;SHELL jmap -histo pid&amp;gt;a.log&lt;/code&gt;可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。&lt;code&gt;jmap -dump:format=b,file=outfile 3024&lt;/code&gt;可以将3024进程的内存heap输出出来到outfile文件里，再配合MAT（内存分析工具(Memory Analysis Tool），使用参见：&lt;a href=&quot;http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx&quot;&gt;http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx&lt;/a&gt;&lt;/a&gt; 或与jhat (Java Heap Analysis Tool)一起使用，能够以图像的形式直观的展示当前内存是否有问题。&lt;/p&gt;
&lt;p&gt;64位机上使用需要使用如下方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmap -J-d64 -heap pid&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Usage:
    jmap [option] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jmap [option] &amp;lt;executable &amp;lt;core&amp;gt;
        (to connect to a core file)
    jmap [option] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to remote debug server)

where &amp;lt;option&amp;gt; is one of:
    &amp;lt;none&amp;gt;               to print same info as Solaris pmap
    -heap                to print java heap summary
    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;
                         suboption is specified, only count live objects
    -clstats             to print class loader statistics
    -finalizerinfo       to print information on objects awaiting finalization
    -dump:&amp;lt;dump-options&amp;gt; to dump java heap in hprof binary format
                         dump-options:
                           live         dump only live objects; if not specified,
                                        all objects in the heap are dumped.
                           format=b     binary format
                           file=&amp;lt;file&amp;gt;  dump heap to &amp;lt;file&amp;gt;
                         Example: jmap -dump:live,format=b,file=heap.bin &amp;lt;pid&amp;gt;
    -F                   force. Use with -dump:&amp;lt;dump-options&amp;gt; &amp;lt;pid&amp;gt; or -histo
                         to force a heap dump or histogram when &amp;lt;pid&amp;gt; does not
                         respond. The &quot;live&quot; suboption is not supported
                         in this mode.
    -h | -help           to print this help message
    -J&amp;lt;flag&amp;gt;             to pass &amp;lt;flag&amp;gt; directly to the runtime system
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;jmap –heap pid&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jmap -heap 5773
Attaching to process ID 5773, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.91-b14

using parallel threads in the new generation. ##新生代采用的是并行线程处理方式
using thread-local object allocation.
Concurrent Mark-Sweep GC ##同步并行垃圾回收

Heap Configuration: ##堆配置情况
   MinHeapFreeRatio         = 40  ##最小堆使用比例
   MaxHeapFreeRatio         = 70 ##最大堆可用比例
   MaxHeapSize              = 1073741824 (1024.0MB) ##最大堆空间大小
   NewSize                  = 348913664 (332.75MB)  ##新生代分配大小   
   MaxNewSize               = 348913664 (332.75MB) ##最大可新生代分配大小
   OldSize                  = 187957248 (179.25MB) ##老生代大小
   NewRatio                 = 2 ##新生代比例
   SurvivorRatio            = 8 ##新生代与suvivor的比例
   MetaspaceSize            = 21807104 (20.796875MB) ##perm区大小  
   CompressedClassSpaceSize = 1073741824 (1024.0MB) 
   MaxMetaspaceSize         = 17592186044415 MB ##最大可分配perm区大小
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:##堆使用情况
New Generation (Eden + 1 Survivor Space):##新生代（伊甸区 + survior空间）
   capacity = 314048512 (299.5MB)  ##伊甸区容量
   used     = 50253216 (47.925201416015625MB) ##已经使用大小
   free     = 263795296 (251.57479858398438MB) ##剩余容量
   16.001736699838272% used  ##使用比例
Eden Space:##伊甸区
   capacity = 279183360 (266.25MB)  ##伊甸区容量
   used     = 50253216 (47.925201416015625MB) ##伊甸区使用
   free     = 228930144 (218.32479858398438MB) #伊甸区当前剩余容量
   18.000075649207748% used ##伊甸区使用情况
From Space: ##survior1区
   capacity = 34865152 (33.25MB) ##survior1区容量
   used     = 0 (0.0MB) ##surviror1区已使用情况
   free     = 34865152 (33.25MB) ##surviror1区剩余容量
   0.0% used ##survior1区使用比例
To Space:  ##survior2 区
   capacity = 34865152 (33.25MB) ##survior2区容量
   used     = 0 (0.0MB) ##survior2区已使用情况
   free     = 34865152 (33.25MB)##survior2区剩余容量
   0.0% used ## survior2区使用比例
concurrent mark-sweep generation: ##老生代使用情况
   capacity = 187957248 (179.25MB) ##老生代容量
   used     = 0 (0.0MB)##老生代已使用容量
   free     = 187957248 (179.25MB)##老生代剩余容量
   0.0% used ##老生代使用比例

3589 interned Strings occupying 288776 bytes.
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-13 15:52:04</pubDate>
            <link>//blog/java-jvm-jmap.html</link>
            <guid isPermaLink="true">//blog/java-jvm-jmap.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>JVM工具 jstack</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-13
title: JVM工具 jstack
tags: java jvm jstack
category: Java
status: publish
summary: JVM工具 jstack 主要用来查看某个Java进程内的线程堆栈信息
--&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息，如果是在64位机器上，需要指定选项&lt;code&gt;-J-d64&lt;/code&gt;，Windows的jstack使用方式只支持以下的这种方式&lt;code&gt;jstack [-l] pid&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;core&lt;/code&gt; 将被打印信息的core dump文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remote-hostname-or-IP&lt;/code&gt; 远程debug服务的主机名或ip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server-id&lt;/code&gt; 唯一id,假如一台主机上多个远程debug服务 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;-F&lt;/code&gt; 当&lt;code&gt;jstack [-l] pid&lt;/code&gt;没有相应的时候强制打印栈信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;打印java和native c/c++框架的所有栈信息.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-h | -help&lt;/code&gt;打印帮助信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pid&lt;/code&gt; 需要被打印配置信息的java进程id,可以用jps查询.&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep&lt;/p&gt;
&lt;p&gt;第一步先找出Java进程ID，我部署在服务器上的Java应用名称为mrf-center：
&lt;code&gt;ps -ef | grep mrf-center | grep -v grep&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步找出该进程内最耗费CPU的线程，可以使用&lt;code&gt;ps -Lfp pid&lt;/code&gt;或者&lt;code&gt;ps -mp pid -o THREAD, tid, time&lt;/code&gt;或者&lt;code&gt;top -Hp pid&lt;/code&gt;，我这里用第三个, TIME列就是各个Java线程耗费的CPU时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printf &quot;%x\n&quot; 21742&lt;/code&gt;得到21742的十六进制值为54ee&lt;/p&gt;
&lt;p&gt;jstack用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack 21711 | grep 54ee&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;实例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;jstack -F 8339&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Attaching to process ID 8339, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.91-b14
Deadlock Detection:

No deadlocks found.

Thread 8357: (state = BLOCKED)
 - java.lang.Thread.sleep(long) @bci=0 (Compiled frame; information may be imprecise)
 - com.zzia.wngn.oom.task.MemTask.run() @bci=44, line=19 (Compiled frame)
 - java.util.concurrent.ThreadPoolExecutor.runWorker(java.util.concurrent.ThreadPoolExecutor$Worker) @bci=95, line=1142 (Interpreted frame)
 - java.util.concurrent.ThreadPoolExecutor$Worker.run() @bci=5, line=617 (Interpreted frame)
 - java.lang.Thread.run() @bci=11, line=745 (Interpreted frame)

Thread 8350: (state = BLOCKED)

Thread 8349: (state = BLOCKED)

Thread 8348: (state = BLOCKED)
 - java.lang.Object.wait(long) @bci=0 (Interpreted frame)
 - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)
 - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Compiled frame)
 - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)

Thread 8347: (state = BLOCKED)
 - java.lang.Object.wait(long) @bci=0 (Interpreted frame)
 - java.lang.Object.wait() @bci=2, line=502 (Compiled frame)
 - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Compiled frame)
 - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)

Thread 8340: (state = BLOCKED)
 - java.lang.Thread.sleep(long) @bci=0 (Compiled frame; information may be imprecise)
 - com.zzia.wngn.oom.OOMServer.main(java.lang.String[]) @bci=134, line=56 (Interpreted frame)
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-13 15:49:37</pubDate>
            <link>//blog/java-jvm-jstack.html</link>
            <guid isPermaLink="true">//blog/java-jvm-jstack.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>JVM工具 jstat</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-13
title: JVM工具 jstat
tags: java jvm jstat
category: Java
status: publish
summary: JVM工具 jstat JVM统计监测工具
--&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Jstat用于监控基于HotSpot的JVM，对其堆的使用情况进行实时的命令行的统计，使用jstat我们可以对指定的JVM做如下监控：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类的加载及卸载情况&lt;/li&gt;
&lt;li&gt;查看新生代、老生代及持久代的容量及使用情况&lt;/li&gt;
&lt;li&gt;查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间&lt;/li&gt;
&lt;li&gt;查看新生代中Eden区及Survior区中容量及分配情况等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;jstat工具特别强大，它有众多的可选项，通过提供多种不同的监控维度，使我们可以从不同的维度来了解到当前JVM堆的使用情况。详细查看堆内各个部分的使用量，使用的时候必须加上待统计的Java进程号，可选的不同维度参数以及可选的统计频率参数。&lt;/p&gt;
&lt;p&gt;它主要是用来显示GC及PermGen相关的信息，如果对GC不怎么了解，先看这篇文章
&lt;a href=&quot;http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx&quot;&gt;http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Usage: jstat -help|-options
       jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]]

Definitions:
  &amp;lt;option&amp;gt;      An option reported by the -options option
  &amp;lt;vmid&amp;gt;        Virtual Machine Identifier. A vmid takes the following form:
                     &amp;lt;lvmid&amp;gt;[@&amp;lt;hostname&amp;gt;[:&amp;lt;port&amp;gt;]]
                Where &amp;lt;lvmid&amp;gt; is the local vm identifier for the target
                Java virtual machine, typically a process id; &amp;lt;hostname&amp;gt; is
                the name of the host running the target Java virtual machine;
                and &amp;lt;port&amp;gt; is the port number for the rmiregistry on the
                target host. See the jvmstat documentation for a more complete
                description of the Virtual Machine Identifier.
  &amp;lt;lines&amp;gt;       Number of samples between header lines.
  &amp;lt;interval&amp;gt;    Sampling interval. The following forms are allowed:
                    &amp;lt;n&amp;gt;[&quot;ms&quot;|&quot;s&quot;]
                Where &amp;lt;n&amp;gt; is an integer and the suffix specifies the units as 
                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.
  &amp;lt;count&amp;gt;       Number of samples to take before terminating.
  -J&amp;lt;flag&amp;gt;      Pass &amp;lt;flag&amp;gt; directly to the runtime system.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;   选项，我们一般使用 -gcutil 查看gc情况&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;vmid&amp;gt;&lt;/code&gt;     vmid 是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;lines&amp;gt;&lt;/code&gt;    lines 行数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;interval&amp;gt;&lt;/code&gt; interval是监控时间间隔，单位为微妙，不提供就意味着单次输出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;    count是最大输出次数,不提供且监控时间间隔有值的话， 就无限打印&lt;/p&gt;
&lt;p&gt;参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程5828垃圾收集状况，一共查询5次，那命令行如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jstat -gc 5828&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选项option代表这用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;–class&lt;/code&gt; 监视类装载、卸载数量、总空间及类装载所耗费的时间,统计classloader的行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gc&lt;/code&gt; 监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量,统计gc行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gccapacity&lt;/code&gt; 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcutil&lt;/code&gt; 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gccause&lt;/code&gt; 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcnew&lt;/code&gt; 监视新生代GC的状况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcnewcapacity&lt;/code&gt; 监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcold&lt;/code&gt; 监视老年代GC的状况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcoldcapacity&lt;/code&gt; 监视内容与——gcold基本相同，输出主要关注使用到的最大和最小空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–gcpermcapacity&lt;/code&gt; 输出永久代使用到的最大和最小空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–compiler&lt;/code&gt; 输出JIT编译器编译过的方法、耗时等信息,统计hotspot just-in-time编译器的行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–printcompilation&lt;/code&gt; 输出已经被JIT编译的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-h n 每n个样本，显示header一次
-t n 在第一列显示时间戳列，时间戳时从jvm启动开始计算&lt;/p&gt;
&lt;h2&gt;输出GC信息 jstat -gc&lt;/h2&gt;
&lt;h4&gt;jstat -gc pid interval count&lt;/h4&gt;
&lt;p&gt;输出的是GC信息，采样时间间隔为250ms，采样数为4&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jstat -gc 21711 250 4&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S0C    S1C    S0U   S1U  EC      EU      OC       OU      PC       PU       YGC  YGCT   FGC FGCT   GCT   
192.0  192.0  64.0  0.0  6144.0  1854.9  32000.0  4111.6  55296.0  25472.7  702  0.431  3   0.218  0.649
192.0  192.0  64.0  0.0  6144.0  1972.2  32000.0  4111.6  55296.0  25472.7  702  0.431  3   0.218  0.649
192.0  192.0  64.0  0.0  6144.0  1972.2  32000.0  4111.6  55296.0  25472.7  702  0.431  3   0.218  0.649
192.0  192.0  64.0  0.0  6144.0  2109.7  32000.0  4111.6  55296.0  25472.7  702  0.431  3   0.218  0.649&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;堆内存 = 年轻代 + 年老代 + 永久代
年轻代 = Eden区 + 两个Survivor区（From和To）

S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）
EC、EU：Eden区容量和使用量
OC、OU：年老代容量和使用量
PC、PU：永久代容量和使用量
YGC、YGT：年轻代GC次数和GC耗时
FGC、FGCT：Full GC次数和Full GC耗时
GCT：GC总耗时
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;输出GC信息 jstat -gcutil&lt;/h2&gt;
&lt;h4&gt;jstat -gcutil pid interval count&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;jstat -gcutil 8339&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  S0     S1     E       O      M       CCS     YGC  YGCT    FGC  FGCT    GCT   
  0.00   0.00   44.09   0.00   17.27   19.75   0    0.000   0    0.000   0.000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;S0  — Heap上的 Survivor space 0 区已使用空间的百分比
S1  — Heap上的 Survivor space 1 区已使用空间的百分比
E   — Heap上的 Eden space 区已使用空间的百分比
O   — Heap上的 Old space 区已使用空间的百分比
P   — Perm space 区已使用空间的百分比
YGC — 从应用程序启动到采样时发生 Young GC 的次数
YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)
FGC — 从应用程序启动到采样时发生 Full GC 的次数
FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)
GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;输出class信息&lt;/h2&gt;
&lt;h4&gt;jstat -class pid&lt;/h4&gt;
&lt;p&gt;显示加载class的数量，及所占空间等信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jstat -class 8339
Loaded  Bytes    Unloaded  Bytes     Time   
1893    3556.3   0         0.0       3.36&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Loaded 装载的类的数量
Bytes 装载类所占用的字节数
Unloaded 卸载类的数量
Bytes 卸载类的字节数
Time 装载和卸载类所花费的时间&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;显示VM实时编译的数量等信息 jstat -compiler&lt;/h2&gt;
&lt;h4&gt;jstat -compiler pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Compiled 编译任务执行数量
Failed 编译任务执行失败数量
Invalid 编译任务执行失效数量
Time 编译任务消耗时间
FailedType 最后一个编译失败任务的类型
FailedMethod 最后一个编译失败任务所在的类及方法&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;显示对象大小 jstat -gccapacity&lt;/h2&gt;
&lt;p&gt;显示VM内存中三代（young,old,perm）对象的使用和占用大小 &lt;/p&gt;
&lt;h4&gt;jstat -gccapacity pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;NGCMN 年轻代(young)中初始化(最小)的大小(字节)
NGCMX 年轻代(young)的最大容量 (字节)
NGC 年轻代(young)中当前的容量 (字节)
S0C 年轻代中第一个survivor（幸存区）的容量 (字节)
S1C 年轻代中第二个survivor（幸存区）的容量 (字节)
EC 年轻代中Eden（伊甸园）的容量 (字节)
OGCMN old代中初始化(最小)的大小 (字节)
OGCMX old代的最大容量(字节)
OGC old代当前新生成的容量 (字节)
OC Old代的容量 (字节)
PGCMN perm代中初始化(最小)的大小 (字节)
PGCMX perm代的最大容量 (字节)
PGC perm代当前新生成的容量 (字节)
PC Perm(持久代)的容量 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
FGC 从应用程序启动到采样时old代(全gc)gc次数&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;年轻代对象的信息 jstat -gcnew&lt;/h2&gt;
&lt;h4&gt;jstat -gcnew pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;S0C 年轻代中第一个survivor（幸存区）的容量 (字节)
S1C 年轻代中第二个survivor（幸存区）的容量 (字节)
S0U 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
S1U 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)
TT 持有次数限制
MTT 最大持有次数限制
EC 年轻代中Eden（伊甸园）的容量 (字节)
EU 年轻代中Eden（伊甸园）目前已使用空间 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
YGCT 从应用程序启动到采样时年轻代中gc所用时间(s)&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;年轻代对象的信息及其占用量 jstat -gcnewcapacity&lt;/h2&gt;
&lt;h4&gt;jstat -gcnewcapacity pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;NGCMN 年轻代(young)中初始化(最小)的大小(字节)
NGCMX 年轻代(young)的最大容量 (字节)
NGC 年轻代(young)中当前的容量 (字节)
S0CMX 年轻代中第一个survivor（幸存区）的最大容量 (字节)
S0C 年轻代中第一个survivor（幸存区）的容量 (字节)
S1CMX 年轻代中第二个survivor（幸存区）的最大容量 (字节)
S1C 年轻代中第二个survivor（幸存区）的容量 (字节)
ECMX 年轻代中Eden（伊甸园）的最大容量 (字节)
EC 年轻代中Eden（伊甸园）的容量 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
FGC 从应用程序启动到采样时old代(全gc)gc次数&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;old代对象的信息 jstat -gcold&lt;/h2&gt;
&lt;h4&gt;jstat -gcold  pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;PC Perm(持久代)的容量 (字节)
PU Perm(持久代)目前已使用空间 (字节)
OC Old代的容量 (字节)
OU Old代目前已使用空间 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
FGC 从应用程序启动到采样时old代(全gc)gc次数
FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)
GCT 从应用程序启动到采样时gc用的总时间(s)&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;old代对象的信息及其占用量 jstat -gcoldcapacity&lt;/h2&gt;
&lt;h4&gt;jstat -gcoldcapacity  pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;OGCMN old代中初始化(最小)的大小 (字节)
OGCMX old代的最大容量(字节)
OGC old代当前新生成的容量 (字节)
OC Old代的容量 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
FGC 从应用程序启动到采样时old代(全gc)gc次数
FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)
GCT 从应用程序启动到采样时gc用的总时间(s)&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;perm对象的信息及其占用量 jstat -gcpermcapacity&lt;/h2&gt;
&lt;h4&gt;jstat -gcpermcapacity  pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;PGCMN perm代中初始化(最小)的大小 (字节)
PGCMX perm代的最大容量 (字节)
PGC perm代当前新生成的容量 (字节)
PC Perm(持久代)的容量 (字节)
YGC 从应用程序启动到采样时年轻代中gc次数
FGC 从应用程序启动到采样时old代(全gc)gc次数
FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)
GCT 从应用程序启动到采样时gc用的总时间(s)&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;当前VM执行的信息 jstat -printcompilation&lt;/h2&gt;
&lt;h4&gt;jstat -printcompilation  pid&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Compiled 编译任务的数目
Size 方法生成的字节码的大小
Type 编译类型
Method 类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-13 15:49:37</pubDate>
            <link>//blog/java-jvm-jstat.html</link>
            <guid isPermaLink="true">//blog/java-jvm-jstat.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>JVM工具 jps</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-13
title: JVM工具 jps
tags: java jvm jps
category: Java
status: publish
summary: JVM工具 jps 用来查看所有的jvm进程，包括进程ID，进程启动的路径等
--&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;用来查看所有的jvm进程，包括进程ID，进程启动的路径等。&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;jps -help
usage: jps [-help]
       jps [-q] [-mlvV] [&amp;lt;hostid&amp;gt;]

Definitions:
    &amp;lt;hostid&amp;gt;:      &amp;lt;hostname&amp;gt;[:&amp;lt;port&amp;gt;]&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;jps&lt;/h2&gt;
&lt;p&gt;默认显示pid和class名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps
6005 Jps
5773 OOMServer&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;-q参数&lt;/h2&gt;
&lt;p&gt;只显示pid，不显示class名称,jar文件名和传递给main 方法的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -q
6028
5773&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;-m参数&lt;/h2&gt;
&lt;p&gt;输出传递给main 方法的参数，在嵌入式jvm上可能是null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -m
6043 Jps -m
5773 OOMServer&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;-l参数&lt;/h2&gt;
&lt;p&gt;输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -l
6149 sun.tools.jps.Jps
5773 com.zzia.wngn.oom.OOMServer&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;-v参数(小写v)&lt;/h2&gt;
&lt;p&gt;输出传递给JVM的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -v
6164 Jps -Dapplication.home=/opt/dev/jdk/jdk1.8.0_91 -Xms8m
5773 OOMServer -Xmx1024m -Xms512m -XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;-V参数(大写V)&lt;/h2&gt;
&lt;p&gt;输出通过文件传递给JVM的参数（如.hotspotrc或通过-XX:Flags=&lt;filename&gt;指定的文件）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -V
6187 Jps
5773 OOMServer&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参数合并使用&lt;/h2&gt;
&lt;p&gt;参数mlvV可以合并一起使用，但是q不能和其他参数一起使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[work@wanggang oom] jps -mlv
6202 sun.tools.jps.Jps -mlv -Dapplication.home=/opt/dev/jdk/jdk1.8.0_91 -Xms8m
5773 com.zzia.wngn.oom.OOMServer -Xmx1024m -Xms512m -XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-13 15:49:37</pubDate>
            <link>//blog/java-jvm-jps.html</link>
            <guid isPermaLink="true">//blog/java-jvm-jps.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>Java线程 ThreadPoolExecutor</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-13
title: Java线程 ThreadPoolExecutor
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Java线程，ThreadPoolExecutor
--&gt;
&lt;h2&gt;Executor接口&lt;/h2&gt;
&lt;p&gt;执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。例如，可能会使用以下方法，而不是为一组任务中的每个任务调用 &lt;code&gt;new Thread(new(RunnableTask())).start()&lt;/code&gt;： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Executor executor = anExecutor;
 executor.execute(new RunnableTask1());
 executor.execute(new RunnableTask2());
 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过，Executor 接口并没有严格地要求执行是异步的。在最简单的情况下，执行程序可以在调用者的线程中立即运行已提交的任务： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; class DirectExecutor implements Executor {
     public void execute(Runnable r) {
         r.run();
     }
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更常见的是，任务是在某个不是调用者线程的线程中执行的。以下执行程序将为每个任务生成一个新线程。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; class ThreadPerTaskExecutor implements Executor {
     public void execute(Runnable r) {
         new Thread(r).start();
     }
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;许多 Executor 实现都对调度任务的方式和时间强加了某种限制。以下执行程序使任务提交与第二个执行程序保持连续，这说明了一个复合执行程序。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; class SerialExecutor implements Executor {
     final Queue&amp;lt;Runnable&amp;gt; tasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
     final Executor executor;
     Runnable active;

     SerialExecutor(Executor executor) {
         this.executor = executor;
     }

     public synchronized void execute(final Runnable r) {
         tasks.offer(new Runnable() {
             public void run() {
                 try {
                     r.run();
                 } finally {
                     scheduleNext();
                 }
             }
         });
         if (active == null) {
             scheduleNext();
         }
     }

     protected synchronized void scheduleNext() {
         if ((active = tasks.poll()) != null) {
             executor.execute(active);
         }
     }
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此包中提供的 Executor 实现实现了 ExecutorService，这是一个使用更广泛的接口。ThreadPoolExecutor 类提供一个可扩展的线程池实现。Executors 类为这些 Executor 提供了便捷的工厂方法。
内存一致性效果：线程中将 Runnable 对象提交到 Executor 之前的操作 happen-before 其执行开始（可能在另一个线程中）。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Executor {
    //在未来某个时间执行给定的命令
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ExecutorService接口&lt;/h2&gt;
&lt;p&gt;Executor 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 &lt;/p&gt;
&lt;p&gt;可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。&lt;code&gt;shutdown()&lt;/code&gt; 方法在终止前允许执行以前提交的任务，而 &lt;code&gt;shutdownNow()&lt;/code&gt; 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。 &lt;/p&gt;
&lt;p&gt;通过创建并返回一个可用于取消执行和/或等待完成的 &lt;code&gt;Future&lt;/code&gt;，方法 &lt;code&gt;submit&lt;/code&gt; 扩展了基本方法&lt;code&gt;Executor.execute(java.lang.Runnable)&lt;/code&gt;。方法 &lt;code&gt;invokeAny&lt;/code&gt; 和 &lt;code&gt;invokeAll&lt;/code&gt; 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成（可使用 &lt;code&gt;ExecutorCompletionService&lt;/code&gt; 类来编写这些方法的自定义变体）。 &lt;/p&gt;
&lt;p&gt;Executors 类提供了用于此包中所提供的执行程序服务的工厂方法。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shutdown()
shutdownNow()
isShutdown()
isTerminated()
awaitTermination(long, TimeUnit)
submit(Callable&amp;lt;T&amp;gt;)
submit(Runnable, T)
submit(Runnable)
invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;)
invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;, long, TimeUnit)
invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;)
invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;, long, TimeUnit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public interface ExecutorService extends Executor {
    //启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 
    void shutdown();

    /**
     * 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。
     * 无法保证能够停止正在处理的活动执行任务，但是会尽力尝试。
     * 例如，通过 Thread.interrupt() 来取消典型的实现，所以任何任务无法响应中断都可能永远无法终止
     */
    List&amp;lt;Runnable&amp;gt; shutdownNow();

    //如果此执行程序已关闭，则返回 true
    boolean isShutdown();

    //如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。 
    boolean isTerminated();

    /**
     * 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。
     * @param timeout 最长等待时间
     * @param unit timeout参数的时间单位
     * @return 如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false 
     */
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回该任务的结果。 
     * 如果想立即阻塞任务的等待，则可以使用 result = exec.submit(aCallable).get(); 形式的构造。
     */ 
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回给定的结果。 
     */
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回 null。 
     */
    Future&amp;lt;?&amp;gt; submit(Runnable task);

    /**
     * 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。
     * 返回列表的所有元素的 Future.isDone() 为 true。
     * 注意，可以正常地或通过抛出异常来终止已完成 任务。如果正在进行此操作时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws InterruptedException;

    /**
     * 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。
     * 返回列表的所有元素的 Future.isDone() 为 true。一旦返回后，即取消尚未完成的任务。
     * 注意，可以正常地或通过抛出异常来终止已完成 任务。如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的
     */
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
     * 如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws InterruptedException, ExecutionException;

    /**
     * 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
     * 如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。
     */
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;AbstractExecutorService抽象类&lt;/h2&gt;
&lt;p&gt;提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。例如，submit(Runnable) 的实现创建了一个关联 RunnableFuture 类，该类将被执行并返回。子类可以重写 newTaskFor 方法，以返回 FutureTask 之外的 RunnableFuture 实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doInvokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;, boolean, long)
invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;)
invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;, long, TimeUnit)
invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;)
invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt;, long, TimeUnit)
newTaskFor(Runnable, T)
newTaskFor(Callable&amp;lt;T&amp;gt;)
submit(Runnable)
submit(Runnable, T)
submit(Callable&amp;lt;T&amp;gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package java.util.concurrent;
import java.util.*;

public abstract class AbstractExecutorService implements ExecutorService {

    /**
     * 为给定可运行任务和默认值返回一个 RunnableFuture。
     * @param runnable 将被包装的可运行任务
     * @param value 用于所返回的将来任务的默认值
     * @return a RunnableFuture，在运行的时候，它将运行底层可运行任务，作为 Future 任务，它将生成给定值作为其结果，并为底层任务提供取消操作。
     */
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
    }

    /**
     * 为给定可调用任务返回一个 RunnableFuture。 
     * @param callable 将包装的可调用任务 
     */
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
        return new FutureTask&amp;lt;T&amp;gt;(callable);
    }

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回给定的结果。 
     */
    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    /**
     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
     * 该 Future 的 get 方法在成功完成时将会返回该任务的结果。 
     * 如果想立即阻塞任务的等待，则可以使用 result = exec.submit(aCallable).get(); 形式的构造。
     */
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    private &amp;lt;T&amp;gt; T doInvokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                            boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
        if (tasks == null)
            throw new NullPointerException();
        int ntasks = tasks.size();
        if (ntasks == 0)
            throw new IllegalArgumentException();
        List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures= new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(ntasks);
        ExecutorCompletionService&amp;lt;T&amp;gt; ecs =
            new ExecutorCompletionService&amp;lt;T&amp;gt;(this);

        // For efficiency, especially in executors with limited
        // parallelism, check to see if previously submitted tasks are
        // done before submitting more of them. This interleaving
        // plus the exception mechanics account for messiness of main
        // loop.

        try {
            // Record exceptions so that if we fail to obtain any
            // result, we can throw the last exception we got.
            ExecutionException ee = null;
            long lastTime = timed ? System.nanoTime() : 0;
            Iterator&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; it = tasks.iterator();

            // Start one task for sure; the rest incrementally
            futures.add(ecs.submit(it.next()));
            --ntasks;
            int active = 1;

            for (;;) {
                Future&amp;lt;T&amp;gt; f = ecs.poll();
                if (f == null) {
                    if (ntasks &amp;gt; 0) {
                        --ntasks;
                        futures.add(ecs.submit(it.next()));
                        ++active;
                    }
                    else if (active == 0)
                        break;
                    else if (timed) {
                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                        if (f == null)
                            throw new TimeoutException();
                        long now = System.nanoTime();
                        nanos -= now - lastTime;
                        lastTime = now;
                    }
                    else
                        f = ecs.take();
                }
                if (f != null) {
                    --active;
                    try {
                        return f.get();
                    } catch (ExecutionException eex) {
                        ee = eex;
                    } catch (RuntimeException rex) {
                        ee = new ExecutionException(rex);
                    }
                }
            }

            if (ee == null)
                ee = new ExecutionException();
            throw ee;

        } finally {
            for (Future&amp;lt;T&amp;gt; f : futures)
                f.cancel(true);
        }
    }

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException {
        try {
            return doInvokeAny(tasks, false, 0);
        } catch (TimeoutException cannotHappen) {
            assert false;
            return null;
        }
    }

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        return doInvokeAny(tasks, true, unit.toNanos(timeout));
    }

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(tasks.size());
        boolean done = false;
        try {
            for (Callable&amp;lt;T&amp;gt; t : tasks) {
                RunnableFuture&amp;lt;T&amp;gt; f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (Future&amp;lt;T&amp;gt; f : futures) {
                if (!f.isDone()) {
                    try {
                        f.get();
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (Future&amp;lt;T&amp;gt; f : futures)
                    f.cancel(true);
        }
    }

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        if (tasks == null || unit == null)
            throw new NullPointerException();
        long nanos = unit.toNanos(timeout);
        List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(tasks.size());
        boolean done = false;
        try {
            for (Callable&amp;lt;T&amp;gt; t : tasks)
                futures.add(newTaskFor(t));

            long lastTime = System.nanoTime();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            Iterator&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; it = futures.iterator();
            while (it.hasNext()) {
                execute((Runnable)(it.next()));
                long now = System.nanoTime();
                nanos -= now - lastTime;
                lastTime = now;
                if (nanos &amp;lt;= 0)
                    return futures;
            }

            for (Future&amp;lt;T&amp;gt; f : futures) {
                if (!f.isDone()) {
                    if (nanos &amp;lt;= 0)
                        return futures;
                    try {
                        f.get(nanos, TimeUnit.NANOSECONDS);
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    } catch (TimeoutException toe) {
                        return futures;
                    }
                    long now = System.nanoTime();
                    nanos -= now - lastTime;
                    lastTime = now;
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (Future&amp;lt;T&amp;gt; f : futures)
                    f.cancel(true);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;AtomicInteger原子操作int&lt;/h2&gt;
&lt;p&gt;可以用原子方式更新的 int 值。AtomicInteger 可用在应用程序中（如以原子方式增加的计数器），并且不能用于替换 Integer。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AtomicInteger extends Number implements java.io.Serializable {

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    static {
      try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
      } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }
    public AtomicInteger() {
    }
    public final int get() {
        return value;
    }
    public final void set(int newValue) {
        value = newValue;
    }

    /**
     * 最后设置为给定值
     */
    public final void lazySet(int newValue) {
        unsafe.putOrderedInt(this, valueOffset, newValue);
    }

    /**
     * 以原子方式设置为给定值，并返回旧值。
     */
    public final int getAndSet(int newValue) {
        for (;;) {
            int current = get();
            if (compareAndSet(current, newValue))
                return current;
        }
    }

    /**
     * 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值
     */
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    /**
     * 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。
     */
    public final boolean weakCompareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    /**
     * 以原子方式将当前值加 1。
     */
    public final int getAndIncrement() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将当前值减 1。
     */
    public final int getAndDecrement() {
        for (;;) {
            int current = get();
            int next = current - 1;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将给定值与当前值相加
     */
    public final int getAndAdd(int delta) {
        for (;;) {
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return current;
        }
    }

    /**
     * 以原子方式将当前值加 1。
     */
    public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

    /**
     * 以原子方式将当前值减 1。
     */
    public final int decrementAndGet() {
        for (;;) {
            int current = get();
            int next = current - 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

    /**
     * 以原子方式将给定值与当前值相加。
     */
    public final int addAndGet(int delta) {
        for (;;) {
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next))
                return next;
        }
    }

    public String toString() {
        return Integer.toString(get());
    }

    public int intValue() {
        return get();
    }

    public long longValue() {
        return (long)get();
    }

    public float floatValue() {
        return (float)get();
    }

    public double doubleValue() {
        return (double)get();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 &lt;/p&gt;
&lt;p&gt;线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 &lt;/p&gt;
&lt;p&gt;为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 &lt;code&gt;Executors.newCachedThreadPool()&lt;/code&gt;（无界线程池，可以进行自动线程回收）、&lt;code&gt;Executors.newFixedThreadPool(int)&lt;/code&gt;（固定大小线程池）和 &lt;code&gt;Executors.newSingleThreadExecutor()&lt;/code&gt;（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时，使用以下指导： &lt;/p&gt;
&lt;h4&gt;核心和最大池大小&lt;/h4&gt;
&lt;p&gt;ThreadPoolExecutor 将根据 corePoolSize 和 maximumPoolSize 设置的边界自动调整池大小。当新任务在方法 &lt;code&gt;execute(java.lang.Runnable)&lt;/code&gt; 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用 &lt;code&gt;setCorePoolSize(int)&lt;/code&gt; 和 &lt;code&gt;setMaximumPoolSize(int)&lt;/code&gt; 进行动态更改。 &lt;/p&gt;
&lt;h4&gt;按需构造&lt;/h4&gt;
&lt;p&gt;默认情况下，即使核心线程最初只是在新任务到达时才创建和启动的，也可以使用方法 &lt;code&gt;prestartCoreThread()&lt;/code&gt; 或 &lt;code&gt;prestartAllCoreThreads()&lt;/code&gt; 对其进行动态重写。如果构造带有非空队列的池，则可能希望预先启动线程。 &lt;/p&gt;
&lt;h4&gt;创建新线程&lt;/h4&gt;
&lt;p&gt;使用 ThreadFactory 创建新线程。如果没有另外说明，则在同一个 ThreadGroup 中一律使用 &lt;code&gt;Executors.defaultThreadFactory()&lt;/code&gt; 创建线程，并且这些线程具有相同的 NORM_PRIORITY 优先级和非守护进程状态。通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态，等等。如果从 newThread 返回 null 时 ThreadFactory 未能创建线程，则执行程序将继续运行，但不能执行任何任务。 &lt;/p&gt;
&lt;h4&gt;保持活动时间&lt;/h4&gt;
&lt;p&gt;如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止。这提供了当池处于非活动状态时减少资源消耗的方法。如果池后来变得更为活动，则可以创建新的线程。也可以使用方法 &lt;code&gt;setKeepAliveTime(long, java.util.concurrent.TimeUnit)&lt;/code&gt; 动态地更改此参数。使用 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;的值在关闭前有效地从以前的终止状态禁用空闲线程。默认情况下，保持活动策略只在有多于 corePoolSizeThreads 的线程时应用。但是只要 keepAliveTime 值非 0，&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; 方法也可将此超时策略应用于核心线程。 &lt;/p&gt;
&lt;h4&gt;排队&lt;/h4&gt;
&lt;p&gt;所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。 &lt;/li&gt;
&lt;li&gt;如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。 &lt;/li&gt;
&lt;li&gt;如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;排队有三种通用策略： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接提交： 工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 &lt;/li&gt;
&lt;li&gt;无界队列： 使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 &lt;/li&gt;
&lt;li&gt;有界队列： 当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;被拒绝的任务&lt;/h4&gt;
&lt;p&gt;当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 &lt;code&gt;execute(java.lang.Runnable)&lt;/code&gt; 中提交的新任务将被拒绝。在以上两种情况下，execute 方法都将调用其 RejectedExecutionHandler 的 &lt;code&gt;RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)&lt;/code&gt; 方法。下面提供了四种预定义的处理程序策略： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时 RejectedExecutionException。 &lt;/li&gt;
&lt;li&gt;在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 &lt;/li&gt;
&lt;li&gt;在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。 &lt;/li&gt;
&lt;li&gt;在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义和使用其他种类的 RejectedExecutionHandler 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。 &lt;/p&gt;
&lt;h4&gt;钩子 (hook) 方法&lt;/h4&gt;
&lt;p&gt;此类提供 protected 可重写的 beforeExecute(java.lang.Thread, java.lang.Runnable) 和 afterExecute(java.lang.Runnable, java.lang.Throwable) 方法，这两种方法分别在执行每个任务之前和之后调用。它们可用于操纵执行环境；例如，重新初始化 ThreadLocal、搜集统计信息或添加日志条目。此外，还可以重写方法 terminated() 来执行 Executor 完全终止后需要完成的所有特殊处理。 &lt;/p&gt;
&lt;p&gt;如果钩子 (hook) 或回调方法抛出异常，则内部辅助线程将依次失败并突然终止。 &lt;/p&gt;
&lt;h4&gt;队列维护&lt;/h4&gt;
&lt;p&gt;方法 getQueue() 允许出于监控和调试目的而访问工作队列。强烈反对出于其他任何目的而使用此方法。    &lt;code&gt;remove(java.lang.Runnable)&lt;/code&gt; 和 &lt;code&gt;purge()&lt;/code&gt; 这两种方法可用于在取消大量已排队任务时帮助进行存储回收。 &lt;/p&gt;
&lt;h4&gt;终止&lt;/h4&gt;
&lt;p&gt;程序 AND 不再引用的池没有剩余线程会自动 shutdown。如果希望确保回收取消引用的池（即使用户忘记调用 shutdown()），则必须安排未使用的线程最终终止：设置适当保持活动时间，使用 0 核心线程的下边界和/或设置   &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   // 1110 0000 0000 0000 0000 0000 0000 0000 | -536870912
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // Integer.SIZE=32  | COUNT_BITS = 29 | 11101
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 1 &amp;lt;&amp;lt; COUNT_BITS = 10 0000 0000 0000 0000 0000 0000 0000 | 536870912 
    // CAPACITY=1 1111  1111 1111 1111 1111 1111 1111=536870911 
    private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    // -1 = 1111 1111 1111 1111 1111 1111 1111 1111
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;//11100000000000000000000000000000|-536870912
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;//0
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;//100000000000000000000000000000 | 536870912
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;//1000000000000000000000000000000| 1073741824
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;//1100000000000000000000000000000| 1610612736
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    // Packing and unpacking ctl 打包和拆包CTL
    //c &amp;amp; 1110 0000 0000 0000 0000 0000 0000 0000 |取高3位 | &amp;amp;与遇0为0，同1为1
    private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
    // c &amp;amp; 1 1111 1111 1111 1111 1111 1111 1111 | 取地位 |
    private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    /*
     * Bit field accessors that don't require unpacking ctl.
     * These depend on the bit layout and on workerCount being never negative.
     * 位字段访问不需要拆包CTL。
     * 这取决于位布局和workerCount是永远不会为负。
     */

    private static boolean runStateLessThan(int c, int s) {
        return c &amp;lt; s;
    }

    private static boolean runStateAtLeast(int c, int s) {
        return c &amp;gt;= s;
    }

    private static boolean isRunning(int c) {
        return c &amp;lt; SHUTDOWN;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;     /**
     * Attempt to CAS-increment the workerCount field of ctl.
     * 预期值加1
     */
    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    /**
     * Attempt to CAS-decrement the workerCount field of ctl.
     * 预期值减1
     */
    private boolean compareAndDecrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect - 1);
    }

    /**
     * Decrements the workerCount field of ctl. This is called only on
     * abrupt termination of a thread (see processWorkerExit). Other
     * decrements are performed within getTask.
     */
    private void decrementWorkerCount() {
        do {} while (! compareAndDecrementWorkerCount(ctl.get()));
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
private final ReentrantLock mainLock = new ReentrantLock();
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();
private final Condition termination = mainLock.newCondition();
private int largestPoolSize;
private long completedTaskCount;
private volatile ThreadFactory threadFactory;
private volatile RejectedExecutionHandler handler;
private volatile long keepAliveTime;
private volatile boolean allowCoreThreadTimeOut;
private volatile int corePoolSize;
private volatile int maximumPoolSize;
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
private static final RuntimePermission shutdownPerm =  new RuntimePermission(&quot;modifyThread&quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock() {
            acquire(1);
        }

        public boolean tryLock() {
            return tryAcquire(1);
        }

        public void unlock() {
            release(1);
        }

        public boolean isLocked() {
            return isHeldExclusively();
        }

        void interruptIfStarted() {
            Thread t;
            if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ThreadPoolExecutor构造函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;corePoolSize：&lt;/code&gt;核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;maximumPoolSize：&lt;/code&gt;线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keepAliveTime：&lt;/code&gt;表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unit：&lt;/code&gt;参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;workQueue：&lt;/code&gt;一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;threadFactory：&lt;/code&gt;线程工厂，主要用来创建线程；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;handler：&lt;/code&gt;表示当拒绝处理任务时的策略，有以下四种取值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     *        线程池中维持的线程数量，即使他们是空闲线程，除非allowCoreThreadTimeOut被设置
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool 线程池允许存在的最大线程数量
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     *        当线程池当前线程数量超过最大线程数量时，空闲线程等待新任务的最大时间
     * @param unit the time unit for the {@code keepAliveTime} argument 时间单位参数
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:&amp;lt;br&amp;gt;
     *         {@code corePoolSize &amp;lt; 0}&amp;lt;br&amp;gt;
     *         {@code keepAliveTime &amp;lt; 0}&amp;lt;br&amp;gt;
     *         {@code maximumPoolSize &amp;lt;= 0}&amp;lt;br&amp;gt;
     *         {@code maximumPoolSize &amp;lt; corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize &amp;lt; 0 ||
            maximumPoolSize &amp;lt;= 0 ||
            maximumPoolSize &amp;lt; corePoolSize ||
            keepAliveTime &amp;lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ThreadPoolExecutor线程池状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; RUNNING &lt;/strong&gt;  运行状态：-1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; SHUTDOWN &lt;/strong&gt; 停工状态：0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; STOP &lt;/strong&gt;     停止状态：1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; TIDYING &lt;/strong&gt;  整理状态：2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; TERMINATED &lt;/strong&gt; 结束状态：3&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;状态描述&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RUNNING:&lt;/code&gt;Accept new tasks and process queued tasks &lt;/p&gt;
&lt;p&gt;接受新的任务和进程排队任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SHUTDOWN:&lt;/code&gt;Don't accept new tasks, but process queued tasks &lt;/p&gt;
&lt;p&gt;不要接受新的任务，但进程排队任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STOP:&lt;/code&gt;Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks &lt;/p&gt;
&lt;p&gt;不要接受新的任务，不处理排队任务，中断正在进行的任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIDYING:&lt;/code&gt;All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method &lt;/p&gt;
&lt;p&gt;所有任务已终止，workerCount为零，线程转换到TIDYING（整理）状态将运行terminated()挂钩方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TERMINATED:&lt;/code&gt;terminated() has completed
terminated（）方法已完成&lt;/p&gt;
&lt;h4&gt;状态转换&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RUNNING -&amp;gt; SHUTDOWN&lt;/code&gt; 调用shutdown(), 也许隐含在finalize（）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(RUNNING or SHUTDOWN) -&amp;gt; STOP&lt;/code&gt; 调用shutdownNow()&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SHUTDOWN -&amp;gt; TIDYING&lt;/code&gt; When both queue and pool are empty&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STOP -&amp;gt; TIDYING&lt;/code&gt; When pool is empty&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIDYING -&amp;gt; TERMINATED&lt;/code&gt; When the terminated() hook method has completed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当创建线程池后，初始时，线程池处于RUNNING状态；&lt;/li&gt;
&lt;li&gt;如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；&lt;/li&gt;
&lt;li&gt;如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；&lt;/li&gt;
&lt;li&gt;当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;execute提交任务&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void execute(Runnable command)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行给定的任务，不会立即执行&lt;/p&gt;
&lt;p&gt;如果少于corePoolSize线程正在运行，尝试启动一个新的线程并使用给定的任务作为他的第一个任务。
调用addWorker呼叫原子检查runState和workerCount，以防止误报警（将当它不能添加线程，返回false）&lt;/p&gt;
&lt;p&gt;如果任务被成功的添加到任务队列，然后我们任需要双重检测是否我们可以添加线程（因为上次检测存在的线程可能会死去）或者线程池在我们进入该方法时线程池已经关闭。因此我们重新检测状态，并在必要时回滚如果停止或启动一个新的线程如果有没有入队。&lt;/p&gt;
&lt;p&gt;如果我们不能排队的任务，那么我们尝试添加一个新的线程。如果失败，我们知道我们正在关闭或饱和，所以拒绝的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();//初始值为0
        //workerCountOf(0) = 0
        //如果当前线程数量小于corePoolSize，创建线程
        if (workerCountOf(c) &amp;lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;workerCountOf&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// c &amp;amp; 0001 1111 1111 1111 1111 1111 1111 1111 | 遇0为0
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;addWorker&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;firstTask&lt;/code&gt; the task the new thread should run first (or null if none). Workers are created with an initial first task (in method execute()) to bypass queuing when there are fewer than corePoolSize threads (in which case we always start one), or when the queue is full (in which case we must bypass queue).  Initially idle threads are usually created via prestartCoreThread or to replace other dying workers.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core&lt;/code&gt; if true use corePoolSize as bound, else&lt;/p&gt;
&lt;p&gt;&lt;code&gt;retry:&lt;/code&gt;标志符 指出下面语句从哪里开始执行 你代码里面有continue retry; 也就是说下面从 retry: 这里继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) { //死循环
            int c = ctl.get();
            int rs = runStateOf(c);
            //获取当前线程池的状态，如果是STOP，TIDYING,TERMINATED状态的话，则会返回false，
            //如果现在状态是SHUTDOWN，但是firstTask不为空或者workQueue为空的话，那么直接返回false。
            // Check if queue empty only if necessary.
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; 
                ! (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; ! workQueue.isEmpty()))
                return false;
            //通过自旋的方式，判断要添加的Worker是否是corePool，
            //如果是的话，那么则判断当前的workerCount是否大于corePoolsize，否则则判断是否大于maximumPoolSize，
            //如果满足的话，说明workerCount超出了线程池大小，直接返回false。
            //如果小于的话，那么判断是否成功将WorkerCount通过CAS操作增加1，
            //如果增加成功的话。则进行到第3步，否则则判断当前线程池的状态，
            //如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue retry重新进行状态的判断
            for (;;) {
                int wc = workerCountOf(c);//当前线程数量
                if (wc &amp;gt;= CAPACITY ||
                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))//线程数加1
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
        //如果满足了的话，那么则创建一个新的Worker对象，
        //然后获取线程池的重入锁后，判断当前线程池的状态，
        //如果当前线程池状态为STOP,TIDYING,TERMINATED的话，
        //那么调用decrementWorkerCount将workerCount减一，
        //然后调用tryTerminate停止线程池，并且返回false。
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            final ReentrantLock mainLock = this.mainLock;
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();
                    int rs = runStateOf(c);

                    if (rs &amp;lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                      //如果状态满足的话，那么则在workers中将新创建的worker添加，
                     //并且重新计算largestPoolSize，然后启动Worker中的线程开始执行任务。
                        workers.add(w);
                        int s = workers.size();
                        if (s &amp;gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-13 14:11:31</pubDate>
            <link>//blog/java-thread-pool.html</link>
            <guid isPermaLink="true">//blog/java-thread-pool.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>CentOS6 alias别名</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 alias别名
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 alias别名 查看命令别名：alias  设置命令别名：alias 别名='命令' 取消命令别名：unalias 别名
--&gt;
&lt;pre&gt;&lt;code&gt;查看命令别名：alias
设置命令别名：alias 别名='命令'
取消命令别名：unalias 别名&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看别名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;alias&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;设置别名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;alias name='command'

alias ll='ls --time-style &quot;+%Y-%m-%d %H:%M:%S&quot; -lht'&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;取消别名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;unalias name

unalias ll&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;设置全局别名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo vi /etc/bash.bashrc
source /etc/bash.bashrc
sudo vi/etc/bashrc
source /etc/bashrc&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;默认别名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias la='ls -la --color=auto'
alias lh='ls -lah --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
# 自定义的别名
alias datetime='date +&quot;%Y-%m-%d %H:%M:%S&quot;'
alias ll='ls --time-style &quot;+%Y-%m-%d %H:%M:%S&quot; -lht --color=auto'&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-alias.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-alias.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 CentOS修改ip</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 CentOS修改ip
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 CentOS修改ip
--&gt;
&lt;h2&gt;临时修改（重启失效）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.0.105&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面接IP地址， 网络掩码和 网关，如果不设置，就使用默认的掩码&lt;/p&gt;
&lt;h2&gt;永久修改&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/sysconfig/network-scripts/ifcfg-eth0 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;DEVICE=&quot;eth0&quot;
BOOTPROTO=&quot;static&quot;
BROADCAST=&quot;192.168.0.255&quot;
DNS1=&quot;192.168.0.1&quot;
GATEWAY=&quot;192.168.0.1&quot;
HWADDR=&quot;00:0C:29:71:EC:09&quot;
IPADDR=&quot;192.168.0.105&quot;
IPV6INIT=&quot;yes&quot;
NETMAST=&quot;255.255.255.0&quot;
NM_CONTROLLED=&quot;yes&quot;
ONBOOT=&quot;yes&quot;
TYPE=&quot;Ethernet&quot;
UUID=&quot;bb249954-ad15-468e-9604-752ce43d641b&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;DEVICE=eth0                     网卡对应的设备别名，如ifcfg-eth0第一块网卡 
BOOTPROTO=static                网卡获得ip地址的方式，static（静态 ip地址）
                                                     dhcp（通过dhcp协议获取ip）
                                                     bootip通过bootp协议获得的ip地址 
BROADCAST=192.168.0.255         子网广播地址 
HWADDR=00:50:56:8E:47:EE        网卡物理地址 
IPADDR=192.168.0.105            网卡IP地址
IPV6INIT=no                     是否启用IPV6 IPV6_AUTOCONF=no 
NETMASK=255.255.255.0           网卡对应网络掩码 
NETWORK=192.168.1.0             网卡对应的网络地址 
ONBOOT=yes                      系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。默认设置为yes&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;重启网络服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;service network restart 
# 或
/etc/init.d/network restart&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-ip.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-ip.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 修改环境变量</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 修改环境变量
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 修改环境变量
--&gt;
&lt;h2&gt;修改系统环境变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/profile&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/opt/dev/jdk/jdk1.7.0_67
export PATH=$PATH:$JAVA_HOME/bin&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;修改用户环境变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vi /root/.bash_profile
vi /home/user/.bash_profile
vi ~/.bash_profile&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/opt/dev/jdk/jdk1.7.0_67
export PATH=$PATH:$JAVA_HOME/bin&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-env.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-env.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 查看端口占用</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 查看端口占用
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 查看端口占用
--&gt;
&lt;h2&gt;shell命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    lsof -i tcp:80
    netstat -ntlp
    netstat -nlp | grep port
    netstat -anp|grep port&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-port.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-port.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 修改hosts和hostname</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 修改hosts和hostname
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 修改hosts和hostname
--&gt;
&lt;h2&gt;修改hostname&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/sysconfig/network
vi /etc/sysconfig/network&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;NETWORKING=yes
HOSTNAME=wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;修改hosts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/hosts
vi /etc/hosts&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1 localhost

127.0.0.1 wanggang
192.168.0.100 window.wngn.zzia.com
127.0.0.1 linux.wngn.zzia.com
127.0.0.1 server
127.0.0.1 wngn.com
127.0.0.1 wngn.php.com

127.0.0.1 wngn.test.com
127.0.0.1 php.wngn.com
127.0.0.1 test.wngn.com
127.0.0.1 book.wngn.com
127.0.0.1 resource.wngn.com
127.0.0.1 sources.wngn.com
127.0.0.1 user.wngn.com
127.0.0.1 blog.wngn.com
127.0.0.1 crud.wngn.com

127.0.0.1 www.php.com
127.0.0.1 test.php.com
127.0.0.1 test.lua.com
127.0.0.1 user.lua.com
127.0.0.1 crud.lua.com
127.0.0.1 blog.lua.com
127.0.0.1 www.lua.com
127.0.0.1 echo.lua.com

127.0.0.1 www.blog.com
127.0.0.1 conf.lua.com
127.0.0.1 user.lua.com
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-host.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-host.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 sudo权限</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 sudo权限
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 sudo权限
--&gt;
&lt;h2&gt;linux给用户添加sudo权限&lt;/h2&gt;
&lt;p&gt;有时候，linux下面运行sudo命令，会提示类似： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;xxxis not in the sudoers file.  This incident will be reported.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里，xxx是用户名称，然后导致无法执行sudo命令，这时候，如下解决：
进入超级用户模式。也就是输入&amp;quot;su -&amp;quot;,系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用）
添加文件的写权限。也就是输入命令&amp;quot;chmod u+w /etc/sudoers&amp;quot;。
编辑/etc/sudoers文件。也就是输入命令&amp;quot;vim /etc/sudoers&amp;quot;,进入编辑模式，找到这一 行：&amp;quot;root ALL=(ALL) ALL&amp;quot;在起下面添加&amp;quot;xxx ALL=(ALL) ALL&amp;quot;(这里的xxx是你的用户名)，然后保存退出。
撤销文件的写权限。也就是输入命令&amp;quot;chmod u-w /etc/sudoers&amp;quot;。
然后就行了。&lt;/p&gt;
&lt;h2&gt;执行的shell命令&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;ll /etc/sudoers
sudo chmod u+w /etc/sudoers
sudo vi /etc/sudoers
    root ALL=(ALL) ALL
    user ALL=(ALL) ALL
sudo chmod u-w /etc/sudoers

# 如果sudo时不验证密码则使用下面配置：
wang ALL=(ALL) NOPASSWD: ALL
work ALL=(ALL) NOPASSWD: ALL&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-sudo.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-sudo.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 inittab启动方式</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 inittab启动方式
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 CentOS设置默认启动命令行(不启动图形界面)
--&gt;
&lt;p&gt;CentOS设置默认启动命令行(不启动图形界面),在centOS6 中的修改方法如下:&lt;/p&gt;
&lt;p&gt;1.root登陆，免得老是sudo&lt;/p&gt;
&lt;p&gt;2.打开/etc/inittab 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   vi /etc/inittab&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.在默认的 run level 设置中,可以看到第一行书写如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id:5:initdefault&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(默认的 run level 等级为 5,即图形界面)&lt;/p&gt;
&lt;p&gt;4.将第一行的 5 修改为 3 即可。&lt;/p&gt;
&lt;p&gt;5.保存文件后重启系统你就可以看见是启动的文本界面了。&lt;/p&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-inittab.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-inittab.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 chkconfig开机启动</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 chkconfig开机启动
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 chkconfig开机启动 chkconfig --list chkconfig --list name
--&gt;
&lt;h2&gt;chkconfig查看&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;chkconfig --list
chkconfig --list name&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;chkconfig添加&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;chkconfig --add
chkconfig --add name&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;chkconfig删除&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;chkconfig --del
chkconfig --del name&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;chkconfig设置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;chkconfig name on/off

#最后 还有个 --level 应该是对 0-6 某些 等级进行单独设置
chkconfig --level 35 name on/off

chkconfig httpd on
chkconfig --level 35 httpd on 将3和5 设置成on&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;chkconfig等级&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; 等级0表示：表示关机
 等级1表示：单用户模式
 等级2表示：无网络连接的多用户命令行模式
 等级3表示：有网络连接的多用户命令行模式
 等级4表示：不可用
 等级5表示：带图形界面的多用户模式
 等级6表示：重新启动&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;chkconfig使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;service name start
service name stop
service name status
service name restart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vi /etc/rc.d/rc.local
service vsftpd start
service iptables stop&lt;/p&gt;
&lt;p&gt;cd /etc/init.d
cd /etc/rc.d/init.d&lt;/p&gt;
&lt;p&gt;vi wang&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #!/bin/sh
    #add for chkconfig
    #chkconfig: 2345 70 30
    #description: the description of the shell
    #processname: wang
    activemq start
    start-dfs.sh
    start-yarn.sh
    rm -rf /opt/dev/oozie/oozie-4.0.0-cdh5.2.0/logs/*
    rm -rf /opt/dev/oozie/oozie-4.0.0-cdh5.2.0/oozie-server/temp/*
    oozied.sh start&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;chmod +x wang.sh
chkconfig --add wang

2345是指脚本的运行级别，即在2345这4种模式下都可以运行，234都是文本界面，5就是图形界面X
70是指脚本将来的启动顺序号，如果别的程序的启动顺序号比70小（比如44、45），则脚本需要等这些程序都启动以后才启动。
30是指系统关闭时，脚本的停止顺序号。&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;linux 下shell脚本执行多个命令的方法 
1.每个命令之间用;隔开
说明：各命令的执行给果，不会影响其它命令的执行。换句话说，各个命令都会执行，但不保证每个命令都执行成功。
2.每个命令之间用&amp;amp;&amp;amp;隔开
说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕后，执行过程都是成功的。
3.每个命令之间用||隔开
说明：||是或的意思，只有前面的命令执行失败后才去执行下一条命令，直到执行成功一条命令为止&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-chkconfig.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-chkconfig.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 ln软连接</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 ln软连接
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 ln软连接 ln -s sourcepath targetpath
--&gt;
&lt;h2&gt;软连接语法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ln -s sourcepath targetpath&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ant添加软连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ln -s /opt/dev/ant/apache-ant-1.9.4/bin/ant /usr/local/bin/ant&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;maven添加软连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ln -s /opt/dev/maven/apache-maven-3.3.3/bin/mvn /usr/local/bin/mvn&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;jdk添加软连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ln -s /opt/dev/jdk/jdk1.8.0_91/bin/java /usr/local/bin/java
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/javac /usr/local/bin/javac
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/javadoc /usr/local/bin/javadoc
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jhat /usr/local/bin/jhat
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jinfo /usr/local/bin/jinfo
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jmap /usr/local/bin/jmap
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jps /usr/local/bin/jps
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jstack /usr/local/bin/jstack
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/jstat /usr/local/bin/jstat
ln -s /opt/dev/jdk/jdk1.8.0_91/bin/keytool /usr/local/bin/keytool&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;nginx添加软连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;php添加软连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-ln.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-ln.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 firewall防火墙</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 firewall防火墙
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 firewall防火墙 service iptables start|stop|restart|status
--&gt;
&lt;h2&gt;启动防火墙&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;service iptables start
service iptables restart&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;关闭防火墙&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;service iptables stop&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看防火墙&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;service iptables status
whereis iptables
sudo iptables -L
sudo iptables -L -n --line-numbers &lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;设置防火墙&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP

#ssh端口，开启目标端口
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
#http端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
#ftp端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT
iptables -A INPUT -p tcp --dport 20 -j ACCEPT
#svn端口
iptables -A INPUT -p tcp --dport 9999 -j ACCEPT
#tomcat端口
iptables -A INPUT -p tcp --dport 8080 -j ACCEPT
iptables -A INPUT -p tcp --dport 8081 -j ACCEPT
iptables -A INPUT -p tcp --dport 8086 -j ACCEPT
iptables -A INPUT -p tcp --dport 8085 -j ACCEPT

iptables -A INPUT -p icmp -j ACCEPT
iptables -A OUTPUT -p icmp -j ACCEPT

iptables -A INPUT -i lo -p all -j ACCEPT
iptables -A OUTPUT -o lo -p all -j ACCEPT

iptables -A OUTPUT -p tcp --sport 31337 -j DROP
iptables -A OUTPUT -p tcp --dport 31337 -j DROP

#对外ping
iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;端口开放&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 允许8081端口访问
iptables -A INPUT -p tcp --dport 8081 -j ACCEPT&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;端口转发&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#8101端口转发到80端口，tomcat用
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8101&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;端口测试&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ping ip
telnet ip port

ping 192.168.0.105
telnet 192.168.0.105 8081&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;允许指定IP登录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#允许指定IP登录
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -s 172.24.94.214 -p tcp --dport 22 -j ACCEPT
iptables -D INPUT -s 172.24.94.214 -p tcp --dport 22 -j ACCEPT&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:39</pubDate>
            <link>//blog/linux-centos6-firewall.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-firewall.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 更改时区和时间格式</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 更改时区和时间格式
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 更改时区和时间格式
--&gt;
&lt;h2&gt;修改时区&lt;/h2&gt;
&lt;p&gt;所有的时区相关文件都存放在/usr/share/zoneinfo/下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls -F /usr/share/zoneinfo/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据所需的时区文件做软链接：&lt;/p&gt;
&lt;h4&gt;中国大陆&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;马来西亚&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ln -sf /usr/share/zoneinfo/Asia/Kuala_Lumpur /etc/localtime
# 或者
rm /etc/localtime
cp /usr/share/zoneinfo/Asia/Kuala_Lumpur /etc/localtime&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后顺便修改下/etc/sysconfig/clock中ZONE选项，不改也不影响使用。&lt;/p&gt;
&lt;p&gt;通过date命令查看是否变化&lt;/p&gt;
&lt;p&gt;2010年 07月 27日 星期二 02:52:14 MYT&lt;/p&gt;
&lt;p&gt;表明已经改为马来的时区了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date &quot;+%Y-%m-%d %H:%M:%S&quot; &lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;时间格式&lt;/h2&gt;
&lt;h4&gt;临时更改显示样式，当回话结束后恢复原来的样式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;export TIME_STYLE='+%Y-%m-%d %H:%M:%S'&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;永久改变显示样式，更改后的效果会保存下来&lt;/h4&gt;
&lt;p&gt;修改/etc/profile文件，在文件内容末尾加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export TIME_STYLE='+%Y-%m-%d %H:%M:%S'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行如下命令，使你修改后的/etc/profile文件配置内容生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source /etc/profile&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-time.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-time.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 yum安装软件</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 yum安装软件
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 yum安装软件
--&gt;
&lt;h2&gt;安装gcc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;yum -y install gcc
yum -y install gcc-c++
yum -y install make&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;-- 或者
yum group install &quot;Development Tools&quot;

-- 或者
yum install gcc gcc-c++ kernel-devel&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-yum.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-yum.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 修改root管理员密码和用户操作</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 修改root管理员密码和用户操作
tags: centos
category: Centos
status: publish
summary: 修改root管理员密码和用户操作
--&gt;
&lt;h2&gt;修改root密码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;以root 身份登录(SSH操作)
输入 passwd 命令 就可以看到提示输入新密码了&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户组操作&lt;/h2&gt;
&lt;h4&gt;添加组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;groupadd groupname&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;groupmod -n groupname newname&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;删除组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;groupdel groupname&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户操作&lt;/h2&gt;
&lt;h4&gt;添加用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;useradd -g groupname username
gpasswd -a username groupname 从组中添加用户&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;设置密码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;passwd username&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;删除用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;userdel username
usermod –g groupname username（强制删除该用户的主目录和主目录下的所有文件和子目录）
gpasswd -d username groupname 从组中删除用户&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;usermod -l username newname
usermod -g groupname username&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;锁定用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;passwd username –l，usermod -l username &lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;释放用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;passwd username –u，usermod -u username &lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看权限&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;id
id user&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-user.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-user.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>CentOS6 关机与重启</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-09-03
title: CentOS6 关机与重启
tags: centos centos6 linux
category: Centos
status: publish
summary: CentOS6 关机与重启
--&gt;
&lt;h2&gt;Linux centos重启命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;reboot
shutdown -r now 立刻重启(root用户使用)
shutdown -r 10 过10分钟自动重启(root用户使用)
shutdown -r 20:35 在时间为20:35时候重启(root用户使用)
shutdown -c 取消重启&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Linux centos关机命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;halt 立刻关机
poweroff 立刻关机
shutdown -h now 立刻关机(root用户使用)
shutdown -h 10 10分钟后自动关机&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-09-03 06:47:40</pubDate>
            <link>//blog/linux-centos6-roboot.html</link>
            <guid isPermaLink="true">//blog/linux-centos6-roboot.html</guid>
                                               <category>Centos</category>
                                    </item>
                <item>
            <title>git使用</title>
            <description>
            &lt;!--
author: wangn123
head: head.png
date: 2016-08-31
title: git使用
tags: git
category: Other
status: publish
summary:git使用，常用命令
--&gt;
&lt;h2&gt;git config&lt;/h2&gt;
&lt;p&gt;使用Git的第一件事就是设置你的名字和email,这些就是你在提交commit时的签名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;wngn123&quot;
git config --global user.email &quot;wngn123@163.com&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行了上面的命令后,会在你的主目录(home directory)建立一个叫~/.gitconfig 的文件. 内容一般像下面这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[user]
name = wngn123
email = wngn123@163.com&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git config 文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config -h
git config --help &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git使用一系列的配置文件来存储你定义的偏好，它首先会查找/etc/gitconfig文件，该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值，如果传递--system选项给git config命令， Git 会读写这个文件。&lt;/p&gt;
&lt;p&gt;接下来Git会查找每个用户的~/.gitconfig文件，你能传递--global选项让Git读写该文件。&lt;/p&gt;
&lt;p&gt;最后Git会查找由用户定义的各个库中Git目录下的配置文件（.git/config），该文件中的值只对该git库有效。如果传递 --local选项给git config命令，Git会读写这个文件。 --local  选项是默认选项&lt;/p&gt;
&lt;p&gt;以上阐述的三层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：在.git/config和/etc/gitconfig的较量中，.git/config取得了胜利。虽然你也可以直接手动编辑这些配置文件，但是运行git config命令将会来得简单些。&lt;/p&gt;
&lt;p&gt;-l, --list 用于列出我们已经设置了的git的配置信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global -l

name = wngn123
email = wngn123@163.com&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;git config --global color.ui true  打开所有的默认终端着色
git config --global core.autocrlf true 如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF
git config --global core.autocrlf false  仅运行在Windows上的项目，可以设置false取消此功能
git config --global core.autocrlf input Linux或Mac CRLF转换成LF，签出时不转换&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;git clone&lt;/h2&gt;
&lt;p&gt;克隆git项目到本地，（第一次创建项目可现在github上创建一个空的项目，任何克隆到本地，在提交）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/wngn123/test.git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。&lt;/p&gt;
&lt;h2&gt;git add&lt;/h2&gt;
&lt;p&gt;克隆到本地的项目被修改后要添加到索引区（index）,使用git add命令&lt;/p&gt;
&lt;p&gt;主要用于把我们要提交的文件的信息添加到索引库中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add file  添加指定变动文件
git add --all 添加所有变动文件&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;git commit&lt;/h2&gt;
&lt;p&gt;提交改的代码到本地git仓库，必须填写注释，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m 'git study 2016-07-20'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的注释：descripe date 如果 git study 2016-07-20&lt;/p&gt;
&lt;h2&gt;git push&lt;/h2&gt;
&lt;p&gt;将当前分推送到github服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git push remote_host localbranch:remotebranch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin master:master
git push origin develop:develop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt;
将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin :master&lt;/code&gt;
如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。等同于&lt;code&gt;git push origin --delete master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin&lt;/code&gt;
如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;
如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/p&gt;
&lt;h2&gt;git pull&lt;/h2&gt;
&lt;p&gt;取回远程主机某个分支的更新，再与本地的指定分支合并&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git pull origin next:master&lt;/code&gt;
取回origin主机的next分支，与本地的master分支合并&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git pull origin next&lt;/code&gt;
取回origin主机的next分支，与本地的当前分支合并,相当于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch origin
git merge origin/next&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git pull origin&lt;/code&gt;
本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;
前分支自动与唯一一个追踪分支进行合并。&lt;/p&gt;
&lt;h2&gt;git fetch&lt;/h2&gt;
&lt;p&gt;从远程获取最新版本到本地，不会自动merge&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch origin master
git log -p master..origin/master
git merge origin/master&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先从远程的origin的master主分支下载最新的版本到origin/master分支上,然后比较本地的master分支和origin/master分支的差别,最后进行合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch origin master:tmp
git diff tmp 
git merge tmp&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从远程获取最新的版本到本地的test分支上,之后再进行比较合并&lt;/p&gt;
&lt;h2&gt;git branch&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git branch new_branch&lt;/code&gt;
创建分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout new_branch&lt;/code&gt;
切换分支
&lt;code&gt;git checkout -b test_branch&lt;/code&gt;
创建和切换分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -D test_branch&lt;/code&gt;
删除分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -m new_branch wchar_support&lt;/code&gt;
重命名分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -r&lt;/code&gt;
显示分支的远程追踪关系&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -a&lt;/code&gt;
显示当前分支和分支的远程追踪关系&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch --track feature1 origin/master&lt;/code&gt;
设置分支的远程追踪关系&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch --set-upstream temp origin/xxx&lt;/code&gt;
设置分支的远程追踪关系&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout -b temp --track origin/xxx&lt;/code&gt;
设置分支的远程追踪关系&lt;/p&gt;
&lt;h2&gt;git tag&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git tag -l&lt;/code&gt;
查看标签&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git show Release_1_0&lt;/code&gt;
查看标签详细信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag -d Release_1_0&lt;/code&gt;
删除标签&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag -a 'Release_1_0' -m 'Tagged basic string operation code' HEAD&lt;/code&gt;
创建标签&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin tag Release_1_0&lt;/code&gt;
创建标签 &lt;/p&gt;
&lt;h4&gt;git status&lt;/h4&gt;
&lt;p&gt;列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status -s&lt;/code&gt;
-s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status -uno&lt;/code&gt;
可以只列出所有已经被git管理的且被修改但没提交的文件。&lt;/p&gt;
&lt;h2&gt;git diff&lt;/h2&gt;
&lt;p&gt;比较working tree(工作目录)同git index(Git索引)之间，git index和git directory(GIT库目录)之间，working tree和git directory之间，git directory中不同commit之间的差异&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地:&lt;/strong&gt; 没有执行git add之前，代码在本地存在  &lt;strong&gt;&lt;em&gt;working tree(工作目录)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暂存区：&lt;/strong&gt; 执行git add后但是没有执行git commit，代码存在于暂存区，本地 &lt;strong&gt;&lt;em&gt;git index(Git索引)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提交列表：&lt;/strong&gt; 执行git commit后，代码存在于提交列表，暂存区，本地 &lt;strong&gt;&lt;em&gt;git directory(GIT库目录)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff  本地和暂存区相比
git dif HEAD 本地和提交列表相比
git dif --cache/--staged 暂存区和提交列表相比&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;git diff [&amp;lt;path&amp;gt;...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令最常用，在每次add进入index前会运行这个命令，查看即将add进入index时所做的内容修改，即working directory和index的差异。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff --cached [&amp;lt;path&amp;gt;...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令初学者不太常用，却非常有用，它表示查看已经add进入index但是尚未commit的内容同最后一次commit时的内容的差异。即index和git directory的差异。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff --cached [&amp;lt;commit&amp;gt;] [&amp;lt;path&amp;gt;...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令初学者用的更少，也非常有用，它表示查看已经add进入index但是尚未commit的内容同指定的&lt;commit&gt;之间的差异，和上面一条很相似，差别仅仅&lt;commit&gt;，即index和git directory中指定版本的差异。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff &amp;lt;commit&amp;gt; [&amp;lt;path&amp;gt;...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令用来查看工作目录和指定&lt;commit&gt;的commit之间的差别，如果要和Git directory中最新版比较差别，则&lt;commit&gt;=HEAD。如果要和某一个branch比较差别，&lt;commit&gt;=分支名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [&amp;lt;path&amp;gt;...]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令用来比较git directory中任意两个&lt;commit&gt;之间的差别，如果想比较任意一个&lt;commit&gt;和最新版的差别，把其中一个&lt;commit&gt;换成HEAD即可。&lt;/p&gt;
&lt;h2&gt;git merge&lt;/h2&gt;
&lt;p&gt;把一个分支或或某个commit的修改合并现在的分支上  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge [options] &amp;lt;msg&amp;gt; HEAD &amp;lt;commit&amp;gt; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的HEAD其实就是分支名，用于说明把HEAD分支合并到当前分支。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge -h
git merge --help

git merge develop   develop分支合并到当前分支
git merge --no-ff develop develop分支快速合并到当前分支（当前分支直接链接到develop分支）&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;git log&lt;/h2&gt;
&lt;p&gt;用于查看提交记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-n 查看最近n次的提交信息&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;n是一个正整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log -2    查看最近2次的提交历史记录&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;-- fileName查看指定文件的提交信息&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;fileName为任意文件名 (注：文件名应该放到参数的最后位置，通常在前面加上--并用空格隔开表示是文件。)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log file1 file2   查看file1文件file2文件的提交记录
git log file/         查看file文件夹下所有文件的提交记录&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--branchName查看莫个分支上的提交记录&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;branchName为任意一个分支名字，同上，需要放到参数中的最后位置处。(注：如果分支名与文件名相同，系统会提示错误，可通过--选项来指定给定的参数是分支名还是文件名。)例：在当前分支中有一个名为v1的文件，同时还存在一个名为v1的分支,则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log v1 -- 此时的v1代表的是分支名字
git log -- v1 此时的v1代表的是名为v1的文件
git log v1 -- v1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;tagName或branchame查询指定标签/分支中的提交记录信息&lt;/strong&gt;  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log v1.0..        查询从v1.0以后的提交历史记录(不包含v1.0)
git log test..master  查询master分支中的提交记录但不包含test分支记录
git log master..test  查询test分支中的提交记录但不办含master分支记录
git log master...test 查询master或test分支中的提交记录。
git log test --not master　　屏蔽master分支&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;根据commit查询日志&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;其中，commit可以是提交哈希值的简写模式，也可以使用HEAD代替。HEAD代表最后一次提交，HEAD^为最后一个提交的父提交，等同于HEAD～1，HEAD～2代表倒数第二次提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log commit  　　查询commit之前的记录，包含commit
git log commit1 commit2 查询commit1与commit2之间的记录，包括commit1和commit2
git log commit1..commit2 同上，但是不包括commit1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--pretty按指定格式显示日志信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可选项有：oneline,short,medium,full,fuller,email,raw以及format:&lt;string&gt;,默认为medium，可以通过修改配置文件来指定默认的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log (--pretty=)oneline
常见的format选项：
选项     说明
%H      提交对象（commit）的完整哈希字串 
%h      提交对象的简短哈希字串 
%T      树对象（tree）的完整哈希字串 
%t      树对象的简短哈希字串 
%P      父对象（parent）的完整哈希字串 
%p      父对象的简短哈希字串 
%an     作者（author）的名字 
%ae     作者的电子邮件地址 
%ad     作者修订日期（可以用 -date= 选项定制格式） 
%ar     作者修订日期，按多久以前的方式显示 
%cn     提交者(committer)的名字 
%ce     提交者的电子邮件地址 
%cd     提交日期 
%cr     提交日期，按多久以前的方式显示 
%s      提交说明 
注：作者是指最后一次修改文件的人；而提交者是指提交该文件的人。
git log --pretty=format:&quot;%an %ae %ad %cn %ce %cd %cr %s&quot; --graph&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--mergs 查看所有合并过的提交历史记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--no-merges     查看所有未被合并过的提交信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--author=someonet       查询指定作者的提交记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log --author=gbyukg&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--since，--affter       仅显示指定时间之后的提交(不包含当前日期)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--until，--before       仅显示指定时间之前的提交(包含当前日期)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log --before={3,weeks,ago} --after={2010-04-18}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--grep  通过提交说明信息过滤提交日志&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log --grep=hotfix 该命令会列出所有包含hotfix字样的提交信息说明的提交记录
注意：如果想同时使用--grep和--author，必须在附加一个--all-match参数。&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;-S      通过查询文件的变更内容来检索出指定提交日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：-S后没有&amp;quot;=&amp;quot;，与查询内容之间也没有空格符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log --Snew&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;-p      查看提交时的补丁信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log -p --no-merges -2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;--stat  列出文件的修改行数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--sortstat      只显示--stat中最后行数修改添加移除的统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--graph 以简单的图形方式列出提交记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--name-only 仅在提交信息后显示已修改的文件清单。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--name-status 显示新增、修改、删除的文件清单。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;git rm&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git rm file&lt;/code&gt;
从staging区移除文件,同时也移除出工作目录.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm --cached&lt;/code&gt;
从staging区移除文件,但留在工作目录中.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm --cached&lt;/code&gt;
从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.&lt;/p&gt;
&lt;h2&gt;git远程追踪&lt;/h2&gt;
&lt;p&gt;在Git中‘追踪分支’是用与联系本地分支和远程分支的. 如果你在’追踪分支'(Tracking Branches)上执行推送(push)或拉取(pull)时,　它会自动推送(push)或拉取(pull)到关联的远程分支上.
如果你经常要从远程仓库里拉取(pull)分支到本地,并且不想很麻烦的使用&amp;quot;git pull &amp;quot;这种格式; 那么就应当使用‘追踪分支'(Tracking Branches).
‘git clone‘命令会自动在本地建立一个'master'分支，它是'origin/master'的‘追踪分支’. 而'origin/master'就是被克隆(clone)仓库的'master'分支.
译者注: origin一般是指原始仓库地址的别名.
你可以在使用'git branch'命令时加上'--track'参数, 来手动创建一个'追踪分支'.
git branch --track experimental origin/experimental
当你运行下命令时:
$ git pull experimental
它会自动从‘origin'抓取(fetch)内容，再把远程的'origin/experimental'分支合并进(merge)本地的'experimental'分支.
当要把修改推送(push)到origin时, 它会将你本地的'experimental'分支中的修改推送到origin的‘experimental'分支里,　而无需指定它(origin).&lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/other-git.html</link>
            <guid isPermaLink="true">//blog/other-git.html</guid>
                                               <category>Other</category>
                                    </item>
                <item>
            <title>Markdown学习</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-31
title: Markdown学习
tags: markdown
category: Other
status: publish
summary:Markdown学习，Markdown基础语法。
--&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题`
##### 五级标题
###### 六级标题&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;列表&lt;/h2&gt;
&lt;p&gt;熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。&lt;/p&gt;
&lt;h4&gt;无序列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    - 无序列表
    - 无序列表
    * 无序列表
    * 无序列表&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表
&lt;h4&gt;有序列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 无序列表
2. 无序列表
3. 无序列表&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;引用&lt;/h2&gt;
&lt;p&gt;如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &lt;code&gt;&amp;gt;&lt;/code&gt; 这种尖括号（大于号）即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 例如这样&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;例如这样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;图片与链接&lt;/h2&gt;
&lt;p&gt;插入链接与插入图片的语法很像，区别在一个 &lt;code&gt;!&lt;/code&gt;号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[baidu](www.baidu.com)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;baidu&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![image](https://raw.githubusercontent.com/wngn123/test/master/img/head.png)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wngn123/test/master/img/head.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;粗体与斜体&lt;/h2&gt;
&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是粗体的语法，用一个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是斜体的语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;** 粗体 **
* 斜体 *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;
&lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;表格&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | 1600 |
| col 2 is      | centered      |   12 |
| zebra stripes | are neat      |    1 |&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Are&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Cool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col 3 is&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;right-aligned&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col 2 is&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;centered&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zebra stripes&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;are neat&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;代码框&lt;/h3&gt;
&lt;p&gt;如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来，如 `code`。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``` python

code
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;@requires_authorization
def somefunc(param1='', param2=0):
    '''A docstring'''
    if param1 &amp;gt; param2: # interesting
        print 'Greater'
    return (param2 - param1 + 1) or None
class SomeClass:
    pass
&amp;gt;&amp;gt;&amp;gt; message = '''interpreter
... prompt'''&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;分割线&lt;/h2&gt;
&lt;p&gt;分割线的语法只需要另起一行，连续输入三个星号 *** 即可。&lt;/p&gt;
&lt;hr /&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/other-markdown.html</link>
            <guid isPermaLink="true">//blog/other-markdown.html</guid>
                                               <category>Other</category>
                                    </item>
                <item>
            <title>Java线程 Runnable和Callable</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-31
title: Java线程 Runnable和Callable
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Java线程
--&gt;
&lt;h2&gt;Java线程&lt;/h2&gt;
&lt;p&gt;在Java中，开启一个线程的唯一方式是，是通过Thread的start方法，并且在线程中执行的Runnable的run方法。无论是线程池还是Callable，Future,最核心最根本的还是调用到&lt;code&gt;Thread.start()–&amp;gt;Runnable.run()&lt;/code&gt;，其他的类的出现可以认为是更方便的使用Thread和Runnable，以此为核心会更容易理解Java的并发框架。&lt;/p&gt;
&lt;p&gt;虽然Thread和Runnable类使得多线程编程简单直接，但有一个缺陷就是：在执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。&lt;/p&gt;
&lt;h2&gt;线程接口Runnable和Callable&lt;/h2&gt;
&lt;p&gt;Callable接口和Runnable接口相似，区别就是Callable需要实现call方法，而Runnable需要实现run方法；并且，call方法还可以返回任何对象，无论是什么对象，JVM都会当作Object来处理。但是如果使用了泛型，我们就不用每次都对Object进行转换了，Callable能够抛出exception,而Runnable不可以。&lt;/p&gt;
&lt;p&gt;Runnable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Runnable {
    public abstract void run();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Callable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Runnable和Thread&lt;/h2&gt;
&lt;p&gt;Thread实现了Runnable接口（可以认为Thread是Runnable的子类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread implements Runnable &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;--------&quot;);
            }
        });
        t.start();
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Callable和Future&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Future&amp;lt;Integer&amp;gt; result = executor.submit(new Callable&amp;lt;Integer&amp;gt;() {
            @Override
            public Integer call() throws Exception {
                System.out.println(&quot;--------&quot;);
                Thread.sleep(3000);
                int sum = 0;
                for (int i = 0; i &amp;lt; 100; i++)
                    sum += i;
                return sum;
            }
        });
        executor.shutdown();
        try {
            System.out.println(&quot;task运行结果&quot; + result.get());
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(&quot;所有任务执行完毕&quot;);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法
public interface Executor {
    //在未来某个时间执行给定的命令。该命令可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。
    void execute(Runnable command);
}&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-thread-interface.html</link>
            <guid isPermaLink="true">//blog/java-thread-interface.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>java源码 Thread</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-30
title: java源码 Thread
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Thread源码
--&gt;
&lt;h2&gt;Thread继承体系&lt;/h2&gt;
&lt;p&gt;Thread的签名如下，继承了实现Runnable接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Thread implements Runnable&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread基本概念&lt;/h2&gt;
&lt;p&gt;线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。
每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。 &lt;/p&gt;
&lt;p&gt;当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止： &lt;/p&gt;
&lt;p&gt;调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。
非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。 &lt;/p&gt;
&lt;p&gt;每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称&lt;/p&gt;
&lt;h2&gt;Thread的属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //线程名
    private char name[];
    //线程优先级
    private int priority;
    /* Whether or not to single_step this thread. */
    private boolean single_step;
    //是否是守护线程
    private boolean daemon = false;
    //虚拟机状态
    private boolean stillborn = false;
    //实际运行的对象，Runnable实例
    private Runnable target;
    //线程组对象
    private ThreadGroup group;
    //上下文类加载器
    private ClassLoader contextClassLoader;
    /* The inherited AccessControlContext of this thread */
    private AccessControlContext inheritedAccessControlContext;
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    private long stackSize;
    private long nativeParkEventPointer;
    private long tid;
    private static long threadSeqNumber;
    private volatile int threadStatus = 0;
    //interrupt status(中断状态)
    volatile Object parkBlocker;
    private volatile Interruptible blocker;
    private final Object blockerLock = new Object();
    //最小优先级
    public final static int MIN_PRIORITY = 1;
   //默认优先级
    public final static int NORM_PRIORITY = 5;
    //最大优先级
    public final static int MAX_PRIORITY = 10;&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread构造函数&lt;/h2&gt;
&lt;p&gt;构造线程需要:ThreadGroup线程组, Runnable线程实例, name线程名, stackSize线程栈大小 AccessControlContext acc&lt;/p&gt;
&lt;p&gt;如果没有设置线程组，则使用父线程线程组&lt;/p&gt;
&lt;p&gt;如果没有设置线程实例，则为null&lt;/p&gt;
&lt;p&gt;如果没有设置线程名称，则默认为：Thread-nextThreadNum&lt;/p&gt;
&lt;p&gt;如果没有设置线程栈大小，则为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public Thread() {
        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
    }

    public Thread(Runnable target) {
        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);
    }

    Thread(Runnable target, AccessControlContext acc) {
        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc);
    }

    public Thread(ThreadGroup group, Runnable target) {
        init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);
    }

    public Thread(String name) {
        init(null, null, name, 0);
    }

    public Thread(ThreadGroup group, String name) {
        init(group, null, name, 0);
    }

    public Thread(Runnable target, String name) {
        init(null, target, name, 0);
    }

    public Thread(ThreadGroup group, Runnable target, String name) {
        init(group, target, name, 0);
    }

    public Thread(ThreadGroup group, Runnable target, String name,
                  long stackSize) {
        init(group, target, name, stackSize);
    }

    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null);
    }

    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc) {
        //线程名称不能为空
        if (name == null) {
            throw new NullPointerException(&quot;name cannot be null&quot;);
        }
        this.name = name.toCharArray();
        //设置父线程为当前线程
        Thread parent = currentThread();
        //获取JVM安全管理器
        SecurityManager security = System.getSecurityManager();
        if (g == null) {
            /* Determine if it's an applet or not */
            /* If there is a security manager, ask the security manager
               what to do. */
            if (security != null) {
                //返回一个新的线程被实例化的ThreadGroup
                g = security.getThreadGroup();
            }
            /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
            if (g == null) {
                g = parent.getThreadGroup();
            }
        }
        //检测当前线程是否有操作线程组的权限
        g.checkAccess();
        /*
         * Do we have the required permissions?
         */
        if (security != null) {
            if (isCCLOverridden(getClass())) {
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
        }
        //线程组添加一个未启动线程，线程组中未启动线程数量加一
        g.addUnstarted();
        this.group = g;
        //继承父线程的守护线程和优先级，类加载器属性
        this.daemon = parent.isDaemon();
        this.priority = parent.getPriority();
        if (security == null || isCCLOverridden(parent.getClass()))
            this.contextClassLoader = parent.getContextClassLoader();
        else
            this.contextClassLoader = parent.contextClassLoader;
        this.inheritedAccessControlContext =
                acc != null ? acc : AccessController.getContext();
        this.target = target;
        setPriority(priority);
        if (parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        /* Stash the specified stack size in case the VM cares */
        this.stackSize = stackSize;

        /* Set thread ID */
        tid = nextThreadID();
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private static int threadInitNumber;
    private static synchronized int nextThreadNum() {
        return threadInitNumber++;
    }
    private static synchronized long nextThreadID() {
        return ++threadSeqNumber;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread的native方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;     //返回当前线程执行对象
    public static native Thread currentThread();
    //使当前执行线程暂停一会，让其它线程得以执行。只是临时让出时间片，不会释放拥有的锁。
    public static native void yield();
    //使当前执行线程休眠指定的时间，不释放持有的锁
    public static native void sleep(long millis) throws InterruptedException;
    //测试线程是否被中断，中断状态是否被重置依赖于传入的ClearInterrupted参数值
    private native boolean isInterrupted(boolean ClearInterrupted);
    //测试线程是否活着，如果线程启动且没有死亡，那么线程是活跃状态
    public final native boolean isAlive();
    //计算该线程中的堆栈帧数。线程必须挂起。
    public native int countStackFrames();
    //当且仅当当前线程在指定的对象上保持监视器锁时，才返回true。该方法旨在使程序能够断言当前线程已经保持一个指定的锁
    public static native boolean holdsLock(Object obj);
    //导出线程栈数据
    private native static StackTraceElement[][] dumpThreads(Thread[] threads);
    //获取所有的线程快照
    private native static Thread[] getThreads();
    //设置线程优先级
    private native void setPriority0(int newPriority);
    //线程启动
    private native void start0();
    //停止线程
    private native void stop0(Object o);
    //状态当前线程
    private native void suspend0();
    //继续执行当前线程
    private native void resume0();
    //这种当前线程的中断标识（没有中断）
    private native void interrupt0();&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread的ID&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //默认线程名的自增
    private static int threadInitNumber;
    private static synchronized int nextThreadNum() {
        return threadInitNumber++;
    }
    //线程ID的自增
    private static long threadSeqNumber;
    private static synchronized long nextThreadID() {
        return ++threadSeqNumber;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread启动&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        //通知线程组线程启动，该线程会被添加到线程组活跃线程数组中，并且活跃线程数加一，未启动线程数量减一
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    //启动失败，线程组中未启动线程数量加一，活跃线程数减一，并且从线程组中移除该线程
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
    private native void start0();&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread睡眠&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //睡眠：毫米，纳秒
    public static void sleep(long millis, int nanos) throws InterruptedException {
        if (millis &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }
        if (nanos &amp;lt; 0 || nanos &amp;gt; 999999) {
            throw new IllegalArgumentException(
                                &quot;nanosecond timeout value out of range&quot;);
        }
        if (nanos &amp;gt;= 500000 || (nanos != 0 &amp;amp;&amp;amp; millis == 0)) {
            millis++;
        }

        sleep(millis);
    }
    public static native void sleep(long millis) throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread的中断&lt;/h2&gt;
&lt;p&gt;线程的thread.interrupt()方法是中断线程，将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。&lt;/p&gt;
&lt;p&gt;判断某个线程是否已被发送过中断请求，请使用Thread.currentThread().isInterrupted()方法（因为它将线程中断标示位设置为true后，不会立刻清除中断标示位，即不会将中断标设置为false），而不要使用thread.interrupted()（该方法调用后会将中断标示位清除，即重新设置为false）方法来判断。&lt;/p&gt;
&lt;p&gt;如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。&lt;/p&gt;
&lt;p&gt;没有任何语言方面的需求一个被中断的线程应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行，但是更普遍的情况是，一个线程将把中断看作一个终止请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //interrupt status(中断状态)
    volatile Object parkBlocker;
    //测试线程中断但不清除中断状态
    public boolean isInterrupted() {
        return isInterrupted(false);
    }
    //测试线程中断并清除中断状态，parkBlocker会被置为空
    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();
        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
    private native void interrupt0();
    private native boolean isInterrupted(boolean ClearInterrupted);&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Thread的join&lt;/h2&gt;
&lt;p&gt;join() 方法是让调用该方法的主线程执行run()时暂时卡住，等run()执行完成后， 主线程再调用执行join()后面的代码。
join()方法会是当前线程等待，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) throws InterruptedException {  
        Thread t1 = new Thread(new ThreadTesterA());  
        Thread t2 = new Thread(new ThreadTesterB());  
        t1.start();  
        t1.join(); // wait t1 to be finished  
        t2.start();  
        t2.join(); // in this program, this may be removed  
    }  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;t1.join()会是当前线程（即main线程处于等待状态，器等待t1线程结束才会继续执行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //让当前线程一直等待，知道线程结束
    public final void join() throws InterruptedException {
        join(0);
    }
    //让当前线程等待一段时间执行，如果参数为0则永远等待
    public final synchronized void join(long millis) throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;
        if (millis &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }
        //如果millis=0，则一直等待，知道线程结束
        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay &amp;lt;= 0) {
                    break;
                }
                // 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
    public final synchronized void join(long millis, int nanos） throws InterruptedException {
        if (millis &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }
        if (nanos &amp;lt; 0 || nanos &amp;gt; 999999) {
            throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
        }
        if (nanos &amp;gt;= 500000 || (nanos != 0 &amp;amp;&amp;amp; millis == 0)) {
            millis++;
        }
        join(millis);
    }&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-src-thread.html</link>
            <guid isPermaLink="true">//blog/java-src-thread.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>java源码 ThreadGroup</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-30
title: java源码 ThreadGroup
tags: java
category: Java
status: publish
summary: 阅读Java的源码，ThreadGroup源码
--&gt;
&lt;h2&gt;ThreadGroup继承体系&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class ThreadGroup implements Thread.UncaughtExceptionHandler&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thread的run方法是不抛出任何检查型异常(checked exception)的,但是它自身却可能因为一个异常而被终止，导致这个线程的终结。最麻烦的是，在线程中抛出的异常即使使用try...catch也无法截获，因此可能导致一些问题出现，比如异常的时候无法回收一些系统资源，或者没有关闭当前的连接等等。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    public void uncaughtException(Thread t, Throwable e) {
        if (parent != null) {
            parent.uncaughtException(t, e);
        } else {
            Thread.UncaughtExceptionHandler ueh =
                Thread.getDefaultUncaughtExceptionHandler();
            if (ueh != null) {
                ueh.uncaughtException(t, e);
            } else if (!(e instanceof ThreadDeath)) {
                System.err.print(&quot;Exception in thread \&quot;&quot;
                                 + t.getName() + &quot;\&quot; &quot;);
                e.printStackTrace(System.err);
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ThreadGroup基本属性&lt;/h2&gt;
&lt;p&gt;线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。 &lt;/p&gt;
&lt;p&gt;允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //父线程组
    private final ThreadGroup parent;
    线程组名称
    String name;
    //线程最大优先级
    int maxPriority;
    //是否被销毁
    boolean destroyed;
    //是否是守护线程组
    boolean daemon;
    //虚拟机是否允许暂停
    boolean vmAllowSuspension;
    //未启动线程数量
    int nUnstartedThreads = 0;
    //启动线程数量
    int nthreads;
    //所有线程快照
    Thread threads[];
    //所有子线程组数量
    int ngroups;
    //所有子线程组快照
    ThreadGroup groups[];&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public String toString() {
        return getClass().getName() + &quot;[name=&quot; + getName() + &quot;,maxpri=&quot; + maxPriority + &quot;]&quot;;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ThreadGroup构造函数&lt;/h2&gt;
&lt;p&gt;构造函数需要父线程组和线程组名称，子线程组会继承父线程的一些属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //创建一个空的线程组且没有父线程组，创建系统线程组时使用，
    private ThreadGroup() {     // called from C code
        this.name = &quot;system&quot;;
        this.maxPriority = Thread.MAX_PRIORITY;
        this.parent = null;
    }

    public ThreadGroup(String name) {
        this(Thread.currentThread().getThreadGroup(), name);
    }

    public ThreadGroup(ThreadGroup parent, String name) {
        this(checkParentAccess(parent), parent, name);
    }

    //Void unused没有使用，提供一种函数调用位，在对象创建之前执行。
    private ThreadGroup(Void unused, ThreadGroup parent, String name) {
        this.name = name;
        this.maxPriority = parent.maxPriority;
        this.daemon = parent.daemon;
        this.vmAllowSuspension = parent.vmAllowSuspension;
        this.parent = parent;
        parent.add(this);//添加到父线程组
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    public final String getName() {
        return name;
    }
    public final int getMaxPriority() {
        return maxPriority;
    }
    public final boolean isDaemon() {
        return daemon;
    }
    public synchronized boolean isDestroyed() {
        return destroyed;
    }
    public final ThreadGroup getParent() {
        if (parent != null)
            parent.checkAccess();
        return parent;
    }

    public final void setDaemon(boolean daemon) {
        checkAccess();
        this.daemon = daemon;
    }

    public final void setMaxPriority(int pri) {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
        synchronized (this) {
            checkAccess();
            if (pri &amp;lt; Thread.MIN_PRIORITY || pri &amp;gt; Thread.MAX_PRIORITY) {
                return;
            }
            maxPriority = (parent != null) ? Math.min(pri, parent.maxPriority) : pri;
            ngroupsSnapshot = ngroups;
            if (groups != null) {
                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
            } else {
                groupsSnapshot = null;
            }
        }
        for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i++) {
            groupsSnapshot[i].setMaxPriority(pri);
        }
    }
    //测试此线程组是否为线程组参数或其祖先线程组之一
    public final boolean parentOf(ThreadGroup g) {
        for (; g != null ; g = g.parent) {
            if (g == this) {
                return true;
            }
        }
        return false;
    }
    //返回当前线程组及其所有子线程组中活动线程的总数
     public int activeCount() {
        int result;
        int ngroupsSnapshot;//活跃子线程数量快照
        ThreadGroup[] groupsSnapshot;//子线程组快照
        synchronized (this) {
            if (destroyed) {
                return 0;
            }
            result = nthreads;
            ngroupsSnapshot = ngroups;
            if (groups != null) {
                //活跃线程组复制一份到线程组快照
                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
            } else {
                groupsSnapshot = null;
            }
        }
        for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i++) {
            result += groupsSnapshot[i].activeCount();
        }
        return result;
    }
    //返回当前线程组及其所有子线程组中活动线程组的总数
    public int activeGroupCount() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
        synchronized (this) {
            if (destroyed) {
                return 0;
            }
            ngroupsSnapshot = ngroups;
            if (groups != null) {
                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
            } else {
                groupsSnapshot = null;
            }
        }
        int n = ngroupsSnapshot;
        for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i++) {
            n += groupsSnapshot[i].activeGroupCount();
        }
        return n;
    } 
    //中断线程组及子线程组中所有线程
    public final void interrupt() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
        synchronized (this) {
            checkAccess();
            for (int i = 0 ; i &amp;lt; nthreads ; i++) {
                threads[i].interrupt();
            }
            ngroupsSnapshot = ngroups;
            if (groups != null) {
                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
            } else {
                groupsSnapshot = null;
            }
        }
        for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i++) {
            groupsSnapshot[i].interrupt();
        }
    }
    //销毁线程组及其所有子线程组
    public final void destroy() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
        synchronized (this) {
            checkAccess();
            if (destroyed || (nthreads &amp;gt; 0)) {
                throw new IllegalThreadStateException();
            }
            ngroupsSnapshot = ngroups;
            if (groups != null) {
                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
            } else {
                groupsSnapshot = null;
            }
            if (parent != null) {
                destroyed = true;
                ngroups = 0;
                groups = null;
                nthreads = 0;
                threads = null;
            }
        }
        for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i += 1) {
            groupsSnapshot[i].destroy();
        }
        if (parent != null) {
            parent.remove(this);
        }
    }

  //添加一个指定的线程组到当前线程组（添加子线程组）
  private final void add(ThreadGroup g){
        synchronized (this) {
            if (destroyed) {
                throw new IllegalThreadStateException();
            }
            if (groups == null) {
                groups = new ThreadGroup[4];
            } else if (ngroups == groups.length) {
                groups = Arrays.copyOf(groups, ngroups * 2);
            }
            groups[ngroups] = g;
            // This is done last so it doesn't matter in case the
            // thread is killed
            ngroups++;
        }
    }
    //从当前线程组中移除一个指定的子线程组
    private void remove(ThreadGroup g) {
        synchronized (this) {
            if (destroyed) {
                return;
            }
            for (int i = 0 ; i &amp;lt; ngroups ; i++) {
                if (groups[i] == g) {
                    ngroups -= 1;
                    System.arraycopy(groups, i + 1, groups, i, ngroups - i);
                    // Zap dangling reference to the dead group so that
                    // the garbage collector will collect it.
                    groups[ngroups] = null;
                    break;
                }
            }
            if (nthreads == 0) {
                notifyAll();
            }
            if (daemon &amp;amp;&amp;amp; (nthreads == 0) &amp;amp;&amp;amp;
                (nUnstartedThreads == 0) &amp;amp;&amp;amp; (ngroups == 0))
            {
                destroy();
            }
        }
    }
    //未启动线程加一，创建线程是被调用
    void addUnstarted() {
        synchronized(this) {
            if (destroyed) {
                throw new IllegalThreadStateException();
            }
            nUnstartedThreads++;
        }
    }
    //添加一个线程到当前线程组中，线程启动时调用
    void add(Thread t) {
        synchronized (this) {
            if (destroyed) {
                throw new IllegalThreadStateException();
            }
            if (threads == null) {
                threads = new Thread[4];
            } else if (nthreads == threads.length) {
                threads = Arrays.copyOf(threads, nthreads * 2);
            }
            //添加启动的线程到线程数组
            threads[nthreads] = t;

            // This is done last so it doesn't matter in case the
            // thread is killed
            nthreads++;

            // The thread is now a fully fledged member of the group, even
            // though it may, or may not, have been started yet. It will prevent
            // the group from being destroyed so the unstarted Threads count is
            // decremented.
            nUnstartedThreads--;
        }
    }
    //线程启动失败
    void threadStartFailed(Thread t) {
        synchronized(this) {
            remove(t);
            nUnstartedThreads++;
        }
    }
    //线程结束操作
    void threadTerminated(Thread t) {
        synchronized (this) {
            remove(t);
            if (nthreads == 0) {
                notifyAll();
            }
            if (daemon &amp;amp;&amp;amp; (nthreads == 0) &amp;amp;&amp;amp;
                (nUnstartedThreads == 0) &amp;amp;&amp;amp; (ngroups == 0))
            {
                destroy();
            }
        }
    }
   //从当前线程组中移除一个指定的子线程，未启动线程数量加一，活动线程数量减一
    private void remove(Thread t) {
        synchronized (this) {
            if (destroyed) {
                return;
            }
            for (int i = 0 ; i &amp;lt; nthreads ; i++) {
                if (threads[i] == t) {
                    System.arraycopy(threads, i + 1, threads, i, --nthreads - i);
                    // Zap dangling reference to the dead thread so that
                    // the garbage collector will collect it.
                    threads[nthreads] = null;
                    break;
                }
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    //检测当前运行的线程是否有权修改此线程组
    public final void checkAccess() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkAccess(this);
        }
    }
    //检测当前运行的线程是否有权修改此线程组的父线程组
    private static Void checkParentAccess(ThreadGroup parent) {
        parent.checkAccess();
        return null;
    }
    private int enumerate(Thread list[], int n, boolean recurse) {
        int ngroupsSnapshot = 0;
        ThreadGroup[] groupsSnapshot = null;
        synchronized (this) {
            if (destroyed) {
                return 0;
            }
            int nt = nthreads;
            if (nt &amp;gt; list.length - n) {
                nt = list.length - n;
            }
            for (int i = 0; i &amp;lt; nt; i++) {
                if (threads[i].isAlive()) {
                    list[n++] = threads[i];
                }
            }
            if (recurse) {
                ngroupsSnapshot = ngroups;
                if (groups != null) {
                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
                } else {
                    groupsSnapshot = null;
                }
            }
        }
        if (recurse) {
            for (int i = 0 ; i &amp;lt; ngroupsSnapshot ; i++) {
                n = groupsSnapshot[i].enumerate(list, n, true);
            }
        }
        return n;
    }&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-src-threadgroup.html</link>
            <guid isPermaLink="true">//blog/java-src-threadgroup.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>Java源码 Short</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-29
title: Java源码 Short
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Short源码
--&gt;
&lt;h2&gt;Short继承体系&lt;/h2&gt;
&lt;p&gt;Short的签名如下，继承了Number类并实现Comparable接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class Short extends Number implements Comparable&amp;lt;Short&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparable接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。强烈推荐（虽然不是必需的）使自然排序与 equals 一致。所谓与equals一致是指对于类C的每一个e1和e2来说，当且仅当 (e1.compareTo((Object)e2) == 0) 与e1.equals((Object)e2) 具有相同的布尔值时，类C的自然排序才叫做与equals一致 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Number为抽象类，提供了实数基本类型的互相转换方法：int,long,short,byte,float,double
Number的基本实现类有java.lang.Byte，java.lang.Double，java.lang.Float，java.lang.Integer，java.lang.Long，java.lang.Short等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public abstract class Number implements java.io.Serializable {
    public abstract int intValue();
    public abstract long longValue();
    public abstract float floatValue();
    public abstract double doubleValue();
    public byte byteValue() {
        return (byte)intValue();
    }
    public short shortValue() {
        return (short)intValue();
    }
    private static final long serialVersionUID = -8742448824652078965L;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Short基本概念&lt;/h2&gt;
&lt;p&gt;Short类包装了short基本类型,所有Short的实际值是存储在一个short类型的属性value上的，short存储占用2字节16位内存，第一位是符号位，所以short的最大值是2的15次幂减1，最小值是负2的15次幂，因此short的最大值是：0111 1111 1111 1111 = 0x7fff = 32767,short的最小值为负值，负数的表示为正值二进制的补码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;负数：正值的补码
补码：反码加一
源码：绝对值二进制
反码：二进制按位取反&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;负数最小值的正值为2的15次幂，正值的二进制为：1000 0000 0000 0000，二进制取反之后为：0111 1111 1111 1111,则正值的补码为：1000 0000 0000 0000，即byte的最小值为：0x8000 = -32768&lt;/p&gt;
&lt;h2&gt;Short构造函数&lt;/h2&gt;
&lt;p&gt;Short有2个构造函数，可以传递一个short数字或者一个数字字符串，数字字符串会被转换成十进制的short数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private final short value;
    public static final short   MIN_VALUE = -32768;
    public static final short   MAX_VALUE = 32767;
    public Short(short value) {
        this.value = value;
    }
    public Short(String s) throws NumberFormatException {
        this.value = parseShort(s, 10);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Short的实例方法&lt;/h2&gt;
&lt;p&gt;Byte实现了从Number类和Comparable接口以及Object继承的方法。Byte提供了可以直接转换成Byte,Short,Integer,Long,Float,Double等基本数值类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public byte byteValue() {
        return (byte)value;
    }
    public short shortValue() {
        return value;
    }
    public int intValue() {
        return (int)value;
    }
    public long longValue() {
        return (long)value;
    }
    public float floatValue() {
        return (float)value;
    }
    public double doubleValue() {
        return (double)value;
    }
    public String toString() {
        return Integer.toString((int)value);
    }
    public int hashCode() {
        return (int)value;
    }
    public boolean equals(Object obj) {
        if (obj instanceof Short) {
            return value == ((Short)obj).shortValue();
        }
        return false;
    }
    public int compareTo(Short anotherShort) {
        return compare(this.value, anotherShort.value);
    }
    public static int compare(short x, short y) {
        return x - y;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ShortCache&lt;/h2&gt;
&lt;p&gt;Short类内部有一个私有的静态内部类ShortCache，该类缓存了部分的的short值到缓存中，从而保证这些byte可以直接获取而不用构造。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private static class ShortCache {
        private ShortCache(){}
        static final Short cache[] = new Short[-(-128) + 127 + 1];
        static {
            for(int i = 0; i &amp;lt; cache.length; i++)
                cache[i] = new Short((short)(i - 128));
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;short转换成Short&lt;/h2&gt;
&lt;p&gt;short转换成Short使用valueOf(short b)方法，该方法会判断short值是否在缓存数值范围之内，如果在缓存中存在，则从ShortCache中获取该值得内存缓存，而不会创建新的Short对象。否则使用构造函数创建新的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static Short valueOf(short s) {
        final int offset = 128;
        int sAsInt = s;
        if (sAsInt &amp;gt;= -128 &amp;amp;&amp;amp; sAsInt &amp;lt;= 127) { // must cache
            return ShortCache.cache[sAsInt + offset];
        }
        return new Short(s);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;String转换成Short&lt;/h2&gt;
&lt;p&gt;String字符串转换成byte使用parseShort(String s, int radix)方法，第一个参数是要转换成short类型的字符串，第二个参数是该字符串的进制数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(Short.parseShort(&quot;11&quot;,10)); //11,10进制数11,转换成byte是11
System.out.println(Short.parseShort(&quot;11&quot;,16)); //17,16进制数11,转换成byte是17
System.out.println(Short.parseShort(&quot;11&quot;,8)); //9,8进制数11,转换成byte是9
System.out.println(Short.parseShort(&quot;11&quot;,2)); //3,2进制数11,转换成byte是3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parseShort方法中会调用Integer中的parseInteger方法处理，如果结果在Short的取值范围之内，这直接转换成short，否则抛出异常。&lt;/p&gt;
&lt;p&gt;parseShort(String s)方法默认10进制解析成shor&lt;/p&gt;
&lt;p&gt;valueOf(String s, int radix)方法首先调用parseShort(String s, int radix)方法将字符串转换成shor类型数值，然后通过valueOf(shor b)方法将shor转换成Short类型的对象。&lt;/p&gt;
&lt;p&gt;valueOf(String s)方法默认10进制解析成Short&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static Short valueOf(String s) throws NumberFormatException {
        return valueOf(s, 10);
    }
    public static Short valueOf(String s, int radix)
        throws NumberFormatException {
        return valueOf(parseShort(s, radix));
    }
    public static short parseShort(String s) throws NumberFormatException {
        return parseShort(s, 10);
    }
    public static short parseShort(String s, int radix)
        throws NumberFormatException {
        int i = Integer.parseInt(s, radix);
        if (i &amp;lt; MIN_VALUE || i &amp;gt; MAX_VALUE)
            throw new NumberFormatException(
                &quot;Value out of range. Value:\&quot;&quot; + s + &quot;\&quot; Radix:&quot; + radix);
        return (short)i;
    }
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-src-Short.html</link>
            <guid isPermaLink="true">//blog/java-src-Short.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>Java源码 Byte</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-29
title: Java源码 Byte
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Byte源码
--&gt;
&lt;h2&gt;Byte继承体系&lt;/h2&gt;
&lt;p&gt;Byte的签名如下，继承了Number类并实现Comparable接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class Byte extends Number implements Comparable&amp;lt;Byte&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparable接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。强烈推荐（虽然不是必需的）使自然排序与 equals 一致。所谓与equals一致是指对于类C的每一个e1和e2来说，当且仅当 (e1.compareTo((Object)e2) == 0) 与e1.equals((Object)e2) 具有相同的布尔值时，类C的自然排序才叫做与equals一致 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Number为抽象类，提供了实数基本类型的互相转换方法：int,long,short,byte,float,double
Number的基本实现类有java.lang.Byte，java.lang.Double，java.lang.Float，java.lang.Integer，java.lang.Long，java.lang.Short等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public abstract class Number implements java.io.Serializable {
    public abstract int intValue();
    public abstract long longValue();
    public abstract float floatValue();
    public abstract double doubleValue();
    public byte byteValue() {
        return (byte)intValue();
    }
    public short shortValue() {
        return (short)intValue();
    }
    private static final long serialVersionUID = -8742448824652078965L;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Byte基本概念&lt;/h2&gt;
&lt;p&gt;Byte类包装了byte基本类型,所有Byte的实际值是存储在一个byte类型的属性value上的，byte存储占用1字节8位内存，第一位是符号位，所以byte的最大值是2的7次幂减1，最小值是负2的7次幂，因此byte的最大值是：0111 1111 = 0x7f = 127,byte的最小值为负值，负数的表示为正值二进制的补码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;负数：正值的补码
补码：反码加一
源码：绝对值二进制
反码：二进制按位取反&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;负数最小值的正值为2的7次幂，正值的二进制为：1000 0000，二进制取反之后为：0111 1111,则正值的补码为：1000 0000，即byte的最小值为：0x80&lt;/p&gt;
&lt;h2&gt;Byte构造函数&lt;/h2&gt;
&lt;p&gt;Byte有2个构造函数，可以传递一个byte数字或者一个数字字符串，数字字符串会被转换成十进制的byte数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private final byte value;
    public static final byte MIN_VALUE = -128;
    public static final byte MAX_VALUE = 127;
    public Byte(byte value) {
        this.value = value;
    }
    public Byte(String s) throws NumberFormatException {
        this.value = parseByte(s, 10);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Byte的实例方法&lt;/h2&gt;
&lt;p&gt;Byte实现了从Number类和Comparable接口以及Object继承的方法。Byte提供了可以直接转换成Short,Integer,Long,Float,Double等数值类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public byte byteValue() {
        return value;
    }
    public short shortValue() {
        return (short)value;
    }
    public int intValue() {
        return (int)value;
    }
    public long longValue() {
        return (long)value;
    }
    public float floatValue() {
        return (float)value;
    }
    public double doubleValue() {
        return (double)value;
    }
    public String toString() {
        return Integer.toString((int)value);
    }
    public int hashCode() {
        return (int)value;
    }
    public boolean equals(Object obj) {
        if (obj instanceof Byte) {
            return value == ((Byte)obj).byteValue();
        }
        return false;
    }
    public int compareTo(Byte anotherByte) {
        return compare(this.value, anotherByte.value);
    }
    public static int compare(byte x, byte y) {
        return x - y;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ByteCache&lt;/h2&gt;
&lt;p&gt;Byte类内部有一个私有的静态内部类ByteCache，该类缓存了全部的的byte值到缓存中，从而保证这些byte可以直接获取而不用构造。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private static class ByteCache {
        private ByteCache(){}
        static final Byte cache[] = new Byte[-(-128) + 127 + 1];
        static {
            for(int i = 0; i &amp;lt; cache.length; i++)
                cache[i] = new Byte((byte)(i - 128));
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;byte转换成Byte&lt;/h2&gt;
&lt;p&gt;byte转换成Byte使用valueOf(byte b)方法，该方法会从ByteCache中获取该值得内存缓存，而不会创建新的Byte对象。如果使用构造函数则会创建新的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static Byte valueOf(byte b) {
        final int offset = 128;
        return ByteCache.cache[(int)b + offset];
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;String转换成Byte&lt;/h2&gt;
&lt;p&gt;String字符串转换成byte使用parseByte(String s, int radix)方法，第一个参数是要转换成byte类型的字符串，第二个参数是该字符串的进制数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(Byte.parseByte(&quot;11&quot;,10)); //11,10进制数11,转换成byte是11
System.out.println(Byte.parseByte(&quot;11&quot;,16)); //17,16进制数11,转换成byte是17
System.out.println(Byte.parseByte(&quot;11&quot;,8)); //9,8进制数11,转换成byte是9
System.out.println(Byte.parseByte(&quot;11&quot;,2)); //3,2进制数11,转换成byte是3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parseByte方法中会调用Integer中的parseInteger方法处理，如果结果在Byte的取值范围之内，这直接转换成byte，否则抛出异常。&lt;/p&gt;
&lt;p&gt;parseByte(String s)方法默认10进制解析成byte&lt;/p&gt;
&lt;p&gt;valueOf(String s, int radix)方法首先调用parseByte(String s, int radix)方法将字符串转换成byte类型数值，然后通过valueOf(byte b)方法将byte转换成Byte类型的对象。&lt;/p&gt;
&lt;p&gt;valueOf(String s)方法默认10进制解析成Byte&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static Byte valueOf(String s) throws NumberFormatException {
        return valueOf(s, 10);
    }
    public static Byte valueOf(String s, int radix)
        throws NumberFormatException {
        return valueOf(parseByte(s, radix));
    }
    public static byte parseByte(String s) throws NumberFormatException {
        return parseByte(s, 10);
    }
    public static byte parseByte(String s, int radix)
        throws NumberFormatException {
        int i = Integer.parseInt(s, radix);
        if (i &amp;lt; MIN_VALUE || i &amp;gt; MAX_VALUE)
            throw new NumberFormatException(
                &quot;Value out of range. Value:\&quot;&quot; + s + &quot;\&quot; Radix:&quot; + radix);
        return (byte)i;
    }
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-src-Byte.html</link>
            <guid isPermaLink="true">//blog/java-src-Byte.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>GitBlog和GitHub同步</title>
            <description>
            &lt;!--
author: wangn123
head: head.png
date: 2016-08-29
title: GitBlog和GitHub同步
tags: git blog
category: GitBlog
status: publish
summary: GitBlog部署本地虚拟机服务器上，在GitHub上通过GotPage功能展示静态网页，每次更新博客将PHP程序静态导出，同步到GitHub仓库中。
--&gt;
&lt;h2&gt;一. 简介&lt;/h2&gt;
&lt;p&gt;GitBlog部署本地虚拟机服务器上，在GitHub上通过GotPage功能展示静态网页，每次更新博客将PHP程序静态导出，同步到GitHub仓库中。&lt;/p&gt;
&lt;h2&gt;二. 导出静态文件&lt;/h2&gt;
&lt;p&gt;GitBlog支持把整个博客网站导出为静态HTML文件，这样导出整个网站后，可以把它上传到网站空间，以静态形式访问，导出的后的网站结构和运行在PHP环境中一样。&lt;/p&gt;
&lt;p&gt;你可以使用以下命令静态导出网站：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;/usr/local/php5/bin/php /home/work/prod/php/gitblog/index.php Gitblog exportSite&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令请换成你的网站路径。成功导出后，会在GitBlog目录下生成一个_site的文件夹，所有导出的静态资源都在这里，你可以随意复制它布署到你的环境中。&lt;/p&gt;
&lt;p&gt;导出前可清除cache目录中的缓存，以便导出最新的资源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo rm -rf /home/work/prod/php/gitblog/app/cache/*&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;三. GitHub同步&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /home/work
git clone https://github.com/wngn123/wngn123.github.io.git
cd wngn123.github.io
rm -rf /home/work/wngn123.github.io/*
cp -rf /home/work/prod/php/gitblog/_site/* /home/work/wngn123.github.io
git status
git add --all
git commit -m 'gitblog 2016-08-29'
git push origin master&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;四. 清理数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /home/work
rm -rf /home/work/wngn123.github.io
rm -rf /home/work/prod/php/gitblog/_site&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/gitblog-github.html</link>
            <guid isPermaLink="true">//blog/gitblog-github.html</guid>
                                               <category>GitBlog</category>
                                    </item>
                <item>
            <title>HTTPS带证书java访问</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: HTTPS带证书java访问
tags: java ssl client
category: HTTPS
status: publish
summary: HTTPS 带证书java访问，Java需要验证客户端证书和服务端证书，客户端证书为P12库，服务端为keystore库，如果服务端证书已经添加到JVM证书库中，则代码可省略服务端的证书验证。
--&gt;
&lt;h2&gt;HTTPS带证书java访问&lt;/h2&gt;
&lt;p&gt;1.Java需要验证客户端证书和服务端证书，客户端证书为P12库，服务端为keystore库，客户端库需要密码，服务端库不需要密码。&lt;/p&gt;
&lt;p&gt;2.如果服务端证书已经添加到JVM证书库中，则代码可省略服务端的证书验证。&lt;/p&gt;
&lt;h4&gt;JAVA SSL&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.dianru.analysis.module.weixin;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.KeyStore;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

public class HttpsPost {
    /** 获得KeyStore.
     * 
     * @param keyStorePath
     *                        密钥库路径
     * @param password
     *                        密码
     * @return 密钥库
     * @throws Exception */
    public static KeyStore getKeyStore(String password, String keyStorePath) throws Exception {
        // 实例化密钥库
        KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
        // 获得密钥库文件流
        FileInputStream is = new FileInputStream(keyStorePath);
        // 加载密钥库
        ks.load(is, password.toCharArray());
        // 关闭密钥库文件流
        is.close();
        return ks;
    }

    /** 获得SSLSocketFactory.
     * 
     * @param password
     *                        密码
     * @param keyStorePath
     *                        密钥库路径
     * @param trustStorePath
     *                        信任库路径
     * @return SSLSocketFactory
     * @throws Exception */
    public static SSLContext getSSLContext(String password, String keyStorePath, String trustStorePath)
            throws Exception {
        // 实例化密钥库
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        // 获得密钥库
        KeyStore keyStore = getKeyStore(password, keyStorePath);
        // 初始化密钥工厂
        keyManagerFactory.init(keyStore, password.toCharArray());

        // 实例化信任库
        TrustManagerFactory trustManagerFactory = TrustManagerFactory
                .getInstance(TrustManagerFactory.getDefaultAlgorithm());
        // 获得信任库
        KeyStore trustStore = getKeyStore(password, trustStorePath);
        // 初始化信任库
        trustManagerFactory.init(trustStore);
        // 实例化SSL上下文
        SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;);
        // 初始化SSL上下文
        ctx.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);
        // 获得SSLSocketFactory
        return ctx;
    }

    /** 初始化HttpsURLConnection.
     * 
     * @param password
     *                        密码
     * @param keyStorePath
     *                        密钥库路径
     * @param trustStorePath
     *                        信任库路径
     * @throws Exception */
    public static void initHttpsURLConnection(String password, String keyStorePath, String trustStorePath)
            throws Exception {
        // 声明SSL上下文
        SSLContext sslContext = null;
        // 实例化主机名验证接口
        HostnameVerifier hnv = new MyHostnameVerifier();
        try {
            sslContext = getSSLContext(password, keyStorePath, trustStorePath);
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        }
        if (sslContext != null) {
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
        }
        HttpsURLConnection.setDefaultHostnameVerifier(hnv);
    }

    /** 发送请求.
     * 
     * @param httpsUrl
     *                        请求的地址
     * @param xmlStr
     *                        请求的数据 */
    public static void post(String httpsUrl, String xmlStr) {
        HttpsURLConnection urlCon = null;
        try {
            urlCon = (HttpsURLConnection) (new URL(httpsUrl)).openConnection();
            urlCon.setDoInput(true);
            urlCon.setDoOutput(true);
            urlCon.setRequestMethod(&quot;POST&quot;);
            urlCon.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(xmlStr.getBytes().length));
            urlCon.setUseCaches(false);
            //设置为gbk可以解决服务器接收时读取的数据中文乱码问题
            urlCon.getOutputStream().write(xmlStr.getBytes(&quot;gbk&quot;));
            urlCon.getOutputStream().flush();
            urlCon.getOutputStream().close();
            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                System.out.println(line);
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /** 测试方法.
     * 
     * @param args
     * @throws Exception */
    public static void main(String[] args) throws Exception {
        // 密码
        String password = &quot;wanggang&quot;;
        // 密钥库
        String keyStorePath = &quot;D:/wngn/cert/wngn/java-client.p12&quot;;
        // 信任库
        String trustStorePath = &quot;D:/wngn/cert/wngn/java-server.truststore&quot;;
        // 本地起的https服务
        String httpsUrl = &quot;https://java.vfou.com:8086/data/active/getLatest&quot;;
        // 传输文本
        String xmlStr = &quot;&quot;;
        HttpsPost.initHttpsURLConnection(password, keyStorePath, trustStorePath);
        // 发起请求
        HttpsPost.post(httpsUrl, xmlStr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.dianru.analysis.module.weixin;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;

/**
 * 实现用于主机名验证的基接口。 
 * 在握手期间，如果 URL 的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。
 */
public class MyHostnameVerifier implements HostnameVerifier {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        if(&quot;localhost&quot;.equals(hostname)){
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HTTP CLIENT&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.dianru.analysis.module.weixin;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.net.ssl.SSLContext;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContexts;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/** User: rizenguo Date: 2014/10/29 Time: 14:36 */
public class HttpsRequest {

    public static Logger LOG = LogManager.getLogger(HttpsRequest.class);

    public interface ResultListener {
        public void onConnectionPoolTimeoutError();
    }

    // 表示请求器是否已经做了初始化工作
    private boolean hasInit = false;
    // 请求器的配置
    private RequestConfig requestConfig;

    // HTTP请求器
    private CloseableHttpClient httpClient;

    public HttpsRequest() {
        try {
            init();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void init() throws IOException, KeyStoreException, UnrecoverableKeyException, NoSuchAlgorithmException,
            KeyManagementException {

        KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
        FileInputStream instream = new FileInputStream(new File(&quot;D:/wngn/cert/wngn/java-client.p12&quot;));

        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        FileInputStream instream2 = new FileInputStream(new File(&quot;D:/wngn/cert/wngn/java-server.truststore&quot;));

        try {
            keyStore.load(instream, &quot;wanggang&quot;.toCharArray());// 设置证书密码
            trustStore.load(instream2, &quot;wanggang&quot;.toCharArray());// 设置证书密码
        } catch (CertificateException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } finally {
            instream.close();
        }
        // Trust own CA and all self-signed certs 相信自己的CA和所有自签名的证书 
        SSLContext sslcontext = SSLContexts.custom().loadKeyMaterial(keyStore, &quot;wanggang&quot;.toCharArray())
                .loadTrustMaterial(trustStore).build();
        // Allow TLSv1 protocol only  只允许使用TLSv1协议 
        SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { &quot;TLSv1&quot; }, null,
                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
        httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build();
        // 根据默认超时限制初始化requestConfig
        requestConfig = RequestConfig.custom().setSocketTimeout(10 * 1000).setConnectTimeout(30 * 1000).build();
        hasInit = true;
    }

    public String sendPost(String url) throws UnrecoverableKeyException, KeyManagementException,
            NoSuchAlgorithmException, KeyStoreException, IOException {
        if (!hasInit) {
            init();
        }
        String result = null;
        HttpPost httpPost = new HttpPost(url);
        System.out.println(&quot;API，POST过去的数据是：&quot;);
        // 得指明使用UTF-8编码，否则到API服务器XML的中文不能被成功识别
        StringEntity postEntity = new StringEntity(&quot;&quot;, &quot;UTF-8&quot;);
        httpPost.addHeader(&quot;Content-Type&quot;, &quot;text/xml&quot;);
        httpPost.setEntity(postEntity);
        // 设置请求器的配置
        httpPost.setConfig(requestConfig);

        try {
            HttpResponse response = httpClient.execute(httpPost);
            HttpEntity entity = response.getEntity();
            result = EntityUtils.toString(entity, &quot;UTF-8&quot;);
            System.out.println(result);
        } catch (Exception e) {
            LOG.error(url + &quot;-&quot; + e.getMessage());
            e.printStackTrace();
        } finally {
            httpPost.abort();
        }
        return result;
    }

    private static final String HTTPS_URL = &quot;https://java.vfou.com:8086/data/active/getLatest&quot;;

    public static void main(String[] args) throws UnrecoverableKeyException, KeyManagementException,
            NoSuchAlgorithmException, KeyStoreException, IOException {
        HttpsRequest CLIENT = new HttpsRequest();
        String response = CLIENT.sendPost(HTTPS_URL);
        System.out.println(response);
    }
}
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/https-java-cert.html</link>
            <guid isPermaLink="true">//blog/https-java-cert.html</guid>
                                               <category>HTTPS</category>
                                    </item>
                <item>
            <title>HTTPS 证书keytool</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: HTTPS 证书keytool
tags: keytool
category: HTTPS
status: publish
summary: HTTPS 证书keytool
--&gt;
&lt;h2&gt;证书keytool&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;-genkeypair：生成一对非对称密钥;&lt;/li&gt;
&lt;li&gt;-alias：指定密钥对的别名，该别名是公开的;&lt;/li&gt;
&lt;li&gt;-keyalg：指定加密算法，本例中的采用通用的RAS加密算法;&lt;/li&gt;
&lt;li&gt;-keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个&amp;quot;.keystore&amp;quot;的文件&lt;/li&gt;
&lt;li&gt;-validity 365”含义是证书有效期，365表示1年，默认值是90天&lt;/li&gt;
&lt;li&gt;-keypass 密钥密码&lt;/li&gt;
&lt;li&gt;-storepass 密钥库密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 注意keypass和storepass保持一致 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;证书系统：&lt;/strong&gt; 证书系统管理很多证书库（keystore）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;证书仓库：&lt;/strong&gt;证书仓库管理很多证书条目（alias）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;证书条目：&lt;/strong&gt;证书条目即一条证书&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;证书管理&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;创建
keytool -genkey -alias &quot;name&quot; -keyalg RSA keystore &quot;test.keystore&quot; -storepass password
显示
keytool -printcert -file &quot;test.crt&quot;   
列表
keytool -list -keystore test.keystore [-v -alias name]
导出
keytool -export -alias name -file test.cer -keystore test.keystore
导入
keytool -import -keystore test_cacerts -file test.cer
删除：
keytool -delete -keystore test.keystore -alias name
修改密码
keytool -keypasswd -alias name -keystore test.keystore
keytool -keypasswd -alias name -keypass testtesttest1 -new testtest1 -storepass testtest -keystore test.keystore  &lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;jdk证书&lt;/h4&gt;
&lt;p&gt;为服务器生成证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keytool -list -keystore %JAVA_HOME%/jre/lib/security/cacerts -v  -alias name
keytool -export -file test.cer -keystore %JAVA_HOME%/jre/lib/security/cacerts -alias name
keytool -import -file test.cer -keystore %JAVA_HOME%/jre/lib/security/cacerts -alias name
keytool -delete -keystore %JAVA_HOME%/jre/lib/security/cacerts -alias name&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;window实例：&lt;/h4&gt;
&lt;p&gt;证书库路径：D:/wngn/cert/wngn/wngn.keystore
证书别名：wngn-server wngn-client-1 wngn-client-2 wngn-client-n&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;What is your first and last name?
  [Unknown]:  www.wngn.com
What is the name of your organizational unit?
  [Unknown]:  wngn.com
What is the name of your organization?
  [Unknown]:  wngn
What is the name of your City or Locality?
  [Unknown]:  BJ
What is the name of your State or Province?
  [Unknown]:  BJ
What is the two-letter country code for this unit?
  [Unknown]:  CH
Is CN=java.vfou.com, OU=vfou.com, O=vfou, L=BJ, ST=BJ, C=CH correct?
  [no]:  y

keytool -genkey -alias wngn-server -keyalg RSA -keysize 1024 -keypass wanggang -validity 365 -keystore D:/wngn/cert/wngn/wngn-server.keystore -dname &quot;CN=www.wngn.com,OU=wngn.com,O=wngn,L=BJ,ST=BJ,C=CH&quot; -storepass wanggang -keypass wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;遇到错误&lt;/h4&gt;
&lt;p&gt;输入keystore密码：&lt;/p&gt;
&lt;p&gt;keytool错误： java.io.IOException: Keystore was tampered with, or password was incorrect &lt;/p&gt;
&lt;p&gt;对于很多服务器比如glassfish或者tomcat之类的，在证书过期，我们需要删除时，需要输入保护密码，默认的就是changeit，输入这个密码就可以了。 &lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/https-keytool-cert.html</link>
            <guid isPermaLink="true">//blog/https-keytool-cert.html</guid>
                                               <category>HTTPS</category>
                                    </item>
                <item>
            <title>HTTPS 双向证书</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: HTTPS 双向证书
tags: keytool https
category: HTTPS
status: publish
summary: HTTPS 双向证书
--&gt;
&lt;h2&gt;双向证书&lt;/h2&gt;
&lt;p&gt;服务器(centos)：172.16.1.10 &lt;/p&gt;
&lt;p&gt;127.0.0.1 localhost&lt;/p&gt;
&lt;p&gt;127.0.0.1 java.vfou.com&lt;/p&gt;
&lt;p&gt;本地主机(window)：172.16.1.101&lt;/p&gt;
&lt;p&gt;127.0.0.1 localhost&lt;/p&gt;
&lt;p&gt;172.16.1.10 java.vfou.com&lt;/p&gt;
&lt;h6&gt;1.生成服务端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -genkey -v -alias java-server -keyalg RSA -keystore /home/java/cert/java/java-server.keystore -dname &quot;CN=java.vfou.com,OU=vfou.com,O=vfou,L=BJ,ST=BJ,C=CH&quot; -storepass wanggang -keypass wanggang &lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;2.导出服务端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -export -v -alias java-server -keystore /home/java/cert/java/java-server.keystore -storepass wanggang -rfc -file /home/java/cert/java/java-server.cer&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;3.生产客户端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -validity 365 -genkeypair -v -alias java-client -keyalg RSA -storetype PKCS12 -keystore D:/wngn/cert/wngn/java-client.p12 -dname &quot;CN=client,OU=client,O=client,L=BJ,ST=BJ,c=CH&quot; -storepass wanggang -keypass wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;4.导出客户端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -export -v -alias java-client -keystore D:/wngn/cert/wngn/java-client.p12 -storetype PKCS12 -storepass wanggang -rfc -file D:/wngn/cert/wngn/java-client.cer&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;5.服务端信任客户端：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -import -v -alias java-client -file  /home/java/cert/java/java-client.cer -keystore /home/java/cert/java/java-server.keystore -storepass wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;6.客户端信任服务端：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -import -v -alias java-server -file D:/wngn/cert/wngn/java-server.cer -keystore D:/wngn/cert/wngn/java-server.truststore -storepass wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;7.服务器tomcat配置：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8086&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
               keystoreFile=&quot;/home/java/cert/java/java-server.keystore&quot; keystorePass=&quot;wanggang&quot;
               truststoreFile=&quot;/home/java/cert/java/java-server.keystore&quot; truststorePass=&quot;wanggang&quot;
               clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;clientAuth:设置是否双向验证，默认为false，设置为true代表双向验证
keystoreFile:服务器证书文件路径
keystorePass:服务器证书密码
truststoreFile:用来验证客户端证书的根证书，此例中就是服务器证书
truststorePass:根证书密码&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;8.让服务器信任客户端证书&lt;/h6&gt;
&lt;p&gt;由于是双向SSL认证，服务器必须要信任客户端证书，因此，必须把客户端证书添加为服务器的信任认证。由于不能直接将PKCS12格式的证书库导入，必须先把客户端证书导出为一个单独的CER文件,然后再将CER文件导入到服务端证书库。&lt;/p&gt;
&lt;h6&gt;9.让客户端信任服务器证书&lt;/h6&gt;
&lt;p&gt;由于是双向SSL认证，客户端也要验证服务器证书，因此，必须把服务器证书添加到浏览的“受信任的根证书颁发机构”。由于不能直接将keystore格式的证书库导入，必须先把服务器证书导出为一个单独的CER文件，然后再将CER文件导入到客户端证书库（windows双击证书安装）。双击tomcat.cer文件，按照提示安装证书，将证书填入到“受信任的根证书颁发机构”。&lt;/p&gt;
&lt;h6&gt;10.让客户端安装客户端（P12）证书&lt;/h6&gt;
&lt;p&gt;浏览器访问必须安装客户端证书，必须将P12的证书库安装到，客户端不是只包含公钥的证书，必须是一个p12库导入才行，证书必须包含私钥才行&lt;/p&gt;
&lt;h6&gt;11.JVM证书导入&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -import -keystore D:/dev/jdk/jdk1.7.0_79/jre/lib/security/cacerts -file D:/wngn/cert/wngn/java-server.crt -alias java-server -storepass changeit&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/https-double-cert.html</link>
            <guid isPermaLink="true">//blog/https-double-cert.html</guid>
                                               <category>HTTPS</category>
                                    </item>
                <item>
            <title>HTTPS 服务端证书</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: HTTPS 服务端证书
tags: keytool https
category: HTTPS
status: publish
summary: HTTPS 服务端证书实现配置
--&gt;
&lt;h2&gt;服务端证书&lt;/h2&gt;
&lt;p&gt;服务器(centos)：172.16.1.10 &lt;/p&gt;
&lt;p&gt;127.0.0.1 localhost&lt;/p&gt;
&lt;p&gt;127.0.0.1 java.vfou.com&lt;/p&gt;
&lt;p&gt;本地主机(window)：172.16.1.101&lt;/p&gt;
&lt;p&gt;127.0.0.1 localhost&lt;/p&gt;
&lt;p&gt;172.16.1.10 java.vfou.com&lt;/p&gt;
&lt;h6&gt;1.生成服务端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -genkey -v -alias java-server -keyalg RSA -keystore /home/java/cert/java/java-server.keystore -dname &quot;CN=java.vfou.com,OU=vfou.com,O=vfou,L=BJ,ST=BJ,C=CH&quot; -storepass wanggang -keypass wanggang &lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;2.导出服务端证书：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -export -v -alias java-server -keystore /home/java/cert/java/java-server.keystore -storepass wanggang -rfc -file /home/java/cert/java/java-server.cer&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;3.客户端信任服务端：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;keytool -import -v -alias java-server -file D:/wngn/cert/wngn/java-server.cer -keystore D:/wngn/cert/wngn/java-server.truststore -storepass wanggang&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;4.服务器tomcat配置：&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8086&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
               keystoreFile=&quot;/home/java/cert/java/java-server.keystore&quot; keystorePass=&quot;wanggang&quot;
               truststoreFile=&quot;/home/java/cert/java/java-server.keystore&quot; truststorePass=&quot;wanggang&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;clientAuth:设置是否双向验证，默认为false，设置为true代表双向验证
keystoreFile:服务器证书文件路径
keystorePass:服务器证书密码
truststoreFile:用来验证客户端证书的根证书，此例中就是服务器证书
truststorePass:根证书密码&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;5.让客户端信任服务器证书&lt;/h6&gt;
&lt;p&gt;由于是服务端认证，客户端要验证服务器证书，因此，必须把服务器证书添加到浏览的“受信任的根证书颁发机构”。由于不能直接将keystore格式的证书库导入，必须先把服务器证书导出为一个单独的CER文件，然后再将CER文件导入到客户端证书库（windows双击证书安装）。双击java-server.cer文件，按照提示安装证书，将证书填入到“受信任的根证书颁发机构”。&lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/https-single-cert.html</link>
            <guid isPermaLink="true">//blog/https-single-cert.html</guid>
                                               <category>HTTPS</category>
                                    </item>
                <item>
            <title>php5.6.25安装</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: php5.6.25安装
tags: php php5
category: PHP
status: publish
summary: php5.6.25安装,centos7源码安装php5.6.25.
--&gt;
&lt;h2&gt;php5.6.25安装&lt;/h2&gt;
&lt;h4&gt;进入Linux源码目录下载源码并安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /usr/local/src
tar -zxvf php-php-5.6.25.tar.gz
cd php-php-5.6.25

./configure --prefix=/usr/local/php5 --with-config-file-path=/usr/local/php5/etc --enable-mb --enable-bcmath --enable-mbstring --enable-sockets --with-curl --enable-ftp --enable-sockets --disable-ipv6 --with-gd --with-jpeg-dir --with-png-dir --with-freetype-dir --enable-gd-native-ttf --with-iconv-t --with-zlib --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-mysql=mysqlnd --enable-dom --enable-xml --enable-fpm 

make &amp;amp;&amp;amp;  make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cp php.ini-production /usr/local/php5/etc/php.ini
cp /usr/local/php5/etc/php-fpm.conf.default /usr/local/php5/etc/php-fpm.conf
cp /src/local/php5/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
#添加启动服务
chmod 755 /etc/init.d/php-fpm 或 chmod +x /etc/init.d/php-fpm
chkconfig --add php-fpm &amp;amp;&amp;amp; chkconfig php-fpm on
chkconfig --level 35 php-fpm on
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;启动&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#验证配置文件
/usr/local/php5/sbin/php-fpm -t
/usr/local/php5/sbin/php-fpm -c /usr/local/php5/etc/php.ini -y /usr/local/php5/etc/php-fpm.conf -t

#服务启动
Usage: /etc/init.d/php-fpm {start|stop|force-quit|restart|reload|status}
service php-fpm start
service php-fpm stop
service php-fpm restart
service php-fpm reload
service php-fpm status

#命令启动
/usr/local/ph5/sbin/php-fpm
/usr/local/php5/bin/php-cgi -b 127.0.0.1:9000 -c /usr/local/php5/etc/php.ini
netstat -tnlp &lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/php-php5-install.html</link>
            <guid isPermaLink="true">//blog/php-php5-install.html</guid>
                                               <category>PHP</category>
                                    </item>
                <item>
            <title>php7.0.10安装</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-28
title: php7.0.10安装
tags: php php7
category: PHP
status: publish
summary: php7.0.10安装,centos7源码安装php7.0.10.
--&gt;
&lt;h2&gt;php7.0.10安装&lt;/h2&gt;
&lt;h4&gt;依赖安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yum -y install libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel pcre-devel
yum -y install curl-devel libmcrypt libmcrypt-devel mcrypt mhash libxslt-devel&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;进入Linux源码目录下载源码并安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /usr/local/src
wget  http://cn2.php.net/distributions/php-7.0.10.tar.gz
tar -zxvf php-7.0.10.tar.gz
cd php-7.0.10

./configure --prefix=/usr/local/php7 --exec-prefix=/usr/local/php7 --bindir=/usr/local/php7/bin --sbindir=/usr/local/php7/sbin --includedir=/usr/local/php7/include --libdir=/usr/local/php7/lib/php --mandir=/usr/local/php7/php/man --with-config-file-path=/usr/local/php7/etc --with-mysql-sock=/var/run/mysql/mysql.sock --with-mcrypt=/usr/include --with-mhash --with-openssl --with-mysql=shared,mysqlnd --with-mysqli=shared,mysqlnd --with-pdo-mysql=shared,mysqlnd --with-gd --with-iconv --with-zlib --enable-zip --enable-inline-optimization --disable-debug --disable-rpath --enable-shared --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --enable-pcntl --enable-sockets --with-xmlrpc --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --enable-fpm --enable-fastcgi --with-fpm-user=work --with-fpm-group=work --without-gdbm --disable-fileinfo

make &amp;amp;&amp;amp;  make install&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#php配置
cp php.ini-production /usr/local/php/etc/php.ini  
cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf
cp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf
cp ./sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
#查看配置文件
sed -e &quot;s/;.*//g&quot;  /usr/local/php7/etc/php.ini | awk '{if (length !=0) print \$0}'
sed -e &quot;s/;.*//g&quot;  /usr/local/php7/etc/php-fpm.d/www.conf   | awk '{if (length !=0) print \$0}'

#添加启动服务
chmod 755 /etc/init.d/php-fpm 或 chmod +x /etc/init.d/php-fpm
chkconfig --add php-fpm &amp;amp;&amp;amp; chkconfig php-fpm on
chkconfig --level 35 php-fpm on
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;启动&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#验证配置文件
/usr/local/php7/sbin/php-fpm -t
/usr/local/php7/sbin/php-fpm -c /usr/local/php7/etc/php.ini -y /usr/local/php7/etc/php-fpm.conf -t

#服务启动
Usage: /etc/init.d/php-fpm {start|stop|force-quit|restart|reload|status}
service php-fpm start
service php-fpm stop
service php-fpm restart
service php-fpm reload
service php-fpm status

#命令启动
/usr/local/ph7/sbin/php-fpm
/usr/local/php7/bin/php-cgi -b 127.0.0.1:9000 -c /usr/local/php7/etc/php.ini
netstat -tnlp 

启动
/etc/init.d/php-fpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;添加php的环境变量&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo -e '\nexport PATH=/usr/local/php7/bin:/usr/local/php7/sbin:\$PATH\n' &amp;gt;&amp;gt; /etc/profile &amp;amp;&amp;amp; source /etc/profile&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/php-php7-install.html</link>
            <guid isPermaLink="true">//blog/php-php7-install.html</guid>
                                               <category>PHP</category>
                                    </item>
                <item>
            <title>OpenResty 安装</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-24
title: OpenResty 安装
tags: lua
category: Lua
status: publish
summary: OpenResty 安装
--&gt;
&lt;h2&gt;相关shell脚本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;    mkdir /home/work/openresty
    cd /home/work/openresty
    git clone https://github.com/wngn123/wngn-luastudy.git
    cd wngn-luastudy
    cp -rf /home/work/openresty/wngn-luastudy/src/openresty/lua /home/work/openresty/
    cp -rf /home/work/openresty/wngn-luastudy/src/openresty/nginx /home/work/openresty/
    sudo cp -rf /home/work/openresty/nginx/nginx.conf /home/local/openresty/nginx/conf/
    sh /home/work/openresty/nginx/nginx_start.sh
&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/lua-openresty-install.html</link>
            <guid isPermaLink="true">//blog/lua-openresty-install.html</guid>
                                               <category>Lua</category>
                                    </item>
                <item>
            <title>nginx lua 环境搭建</title>
            <description>
            &lt;!--
author: wngn123
date: 2016-08-24
title: nginx lua 环境搭建
tags: lua
category: Lua
status: publish
summary: nginx lua 环境搭建
--&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;drwxr-xr-x. 6 wang wang     93 May 15  2015 LuaJIT-2.0.4
-rw-r--r--. 1 root root 847615 Jun  6 21:16 LuaJIT-2.0.4.tar.gz
drwxrwxr-x. 9 root root   4096 May 26 10:41 lua-nginx-module-0.10.5
-rw-r--r--. 1 root root 579793 Jun  6 21:35 lua-nginx-module-0.10.5.tar.gz
drwxr-xr-x. 9 work work   4096 Jun  6 21:25 nginx-1.10.1
-rw-r--r--. 1 root root 909077 Jun  6 21:17 nginx-1.10.1.tar.gz
drwxrwxr-x. 9 root root   4096 May 10 05:28 ngx_devel_kit-0.3.0
-rw-r--r--. 1 root root  66455 Jun  6 21:34 ngx_devel_kit-0.3.0.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#使用root用户登录
yum -y install gcc gcc-c++ autoconf automake
yum -y install zlib zlib-devel openssl openssl-devel pcre-devel&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;下载解压安装文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /usr/local/src
wget http://nginx.org/download/nginx-1.10.1.tar.gz
wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz
wget https://github.com/chaoslawful/lua-nginx-module/archive/v1.10.5.tar.gz
wget https://github.com/simpl/ngx_devel_kit/releases/tag/v0.3.0
tar -zxvf LuaJIT-2.0.4.tar.gz
tar -zxvf nginx-1.10.1.tar.gz

tar -zxvf lua-nginx-module-0.10.5.tar.gz
tar -zxvf ngx_devel_kit-0.3.0.tar.gz
tar -zxvf echo-nginx-module-0.59

tar -zxvf v0.59
tar -zxvf v1.10.5.tar.gz
tar -zxvf v0.3.0.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装LuaJIT&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /usr/local/src/LuaJIT-2.0.4
make
make install
export LUAJIT_LIB=/usr/local/lib
export LUAJIT_INC=/usr/local/include/luajit-2.0
ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装NGINX&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /usr/local/src/nginx-1.10.1
./configure --add-module=/usr/local/src/lua-nginx-module-0.10.5 --add-module=/usr/local/src/ngx_devel_kit-0.3.0
./configure --add-module=/usr/local/src/lua-nginx-module-0.10.5 --add-module=/usr/local/src/ngx_devel_kit-0.3.0 --add-module=/usr/local/src/echo-nginx-module-0.59 
make -j2
make install&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;配置NGINX&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cp /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf.bak
vi /usr/local/nginx/conf/nginx.conf

location ~* ^/2328(/.*) {
    default_type 'text/plain';
    content_by_lua 'ngx.say(&quot;hello, ttlsa lua&quot;)';
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;启动NGINX&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;/usr/local/nginx/sbin/nginx -v
/usr/local/nginx/sbin/nginx&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试NGINX&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl http://localhost/2328/&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;echo命令只能放在url请求中，如果放在url请求外，会报错 如果报[emerg]: &amp;quot;echo&amp;quot; directive is not allowed here in  ，请检查echo放置的位置&lt;/li&gt;
&lt;li&gt;一次url请求，echo 只能打印一行，如果有逻辑判断，且判断成功，则echo会执行判断成功里边的echo，否则执行最后一句echo（此处不一定正确，在测试中发现是此现象）&lt;/li&gt;
&lt;li&gt;如果echo后边有配置return 或者配置 proxy_pass，则echo的输出会被覆盖，即浏览器无法看到echo的内容&lt;/li&gt;
&lt;li&gt;echo的内容不是写在nginx的配置文件中，而是输出到浏览器中，所以echo的打印字符的查看请在浏览器中查看&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ttlsa.com/nginx/nginx-modules-ngx_lua/&quot;&gt;&lt;a href=&quot;http://www.ttlsa.com/nginx/nginx-modules-ngx_lua&quot;&gt;http://www.ttlsa.com/nginx/nginx-modules-ngx_lua&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/lua-nginx-install.html</link>
            <guid isPermaLink="true">//blog/lua-nginx-install.html</guid>
                                               <category>Lua</category>
                                    </item>
                <item>
            <title>Java源码 Integer</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-24
title: Java源码 Integer
tags: java
category: Java
status: publish
summary: 阅读Java的源码，Integer源码
--&gt;
&lt;h2&gt;Integer继承体系&lt;/h2&gt;
&lt;p&gt;Integer的签名如下，继承了Number类并实现Comparable接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class Integer extends Number implements Comparable&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparable接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。强烈推荐（虽然不是必需的）使自然排序与 equals 一致。所谓与equals一致是指对于类C的每一个e1和e2来说，当且仅当 (e1.compareTo((Object)e2) == 0) 与e1.equals((Object)e2) 具有相同的布尔值时，类C的自然排序才叫做与equals一致 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Number为抽象类，提供了实数基本类型的互相转换方法：int,long,short,byte,float,double
Number的基本实现类有java.lang.Byte，java.lang.Double，java.lang.Float，java.lang.Integer，java.lang.Long，java.lang.Short等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public abstract class Number implements java.io.Serializable {
    public abstract int intValue();
    public abstract long longValue();
    public abstract float floatValue();
    public abstract double doubleValue();
    public byte byteValue() {
        return (byte)intValue();
    }
    public short shortValue() {
        return (short)intValue();
    }
    private static final long serialVersionUID = -8742448824652078965L;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Integer基本概念&lt;/h2&gt;
&lt;p&gt;Integer类包装了int基本类型,所有Integer的实际值是存储在一个int类型的熟悉value上的，int存储占用4字节32位内存，第一位是符号位，所以int的最大值是2的31次幂减1，最小值是负2的31次幂，因此int的最大值是：0111 1111 1111 1111 1111 1111 1111 1111=0x7fffffff,int的最小值为负值，负数的表示为正值二进制的补码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;负数：正值的补码
补码：反码加一
源码：绝对值二进制
反码：二进制按位取反&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;负数最小值的正值为2的31次幂，正值的二进制为：1000 0000 0000 0000 00000 0000 0000 0000，二进制取反之后为：0111 1111 1111 1111 1111 1111 1111 1111，则正值的补码为：1000 0000 0000 0000 00000 0000 0000 0000，即int的最小值为：0x80000000&lt;/p&gt;
&lt;h2&gt;Integer构造函数&lt;/h2&gt;
&lt;p&gt;Integer有2个构造函数，可以传递一个int数字或者一个数字字符串，数字字符串会被转换成十进制的int数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private final int value;
    public static final int MIN_VALUE = 0x80000000;
    public static final int MAX_VALUE = 0x7fffffff;
    public static final int SIZE = 32;//int存储位数

    public Integer(int value) {
        this.value = value;
    }
    public Integer(String s) throws NumberFormatException {
        this.value = parseInt(s, 10);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Integer实例方法&lt;/h2&gt;
&lt;p&gt;Integer的实例方法，Integer实现了从Number类和Comparable接口以及Object继承的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public byte byteValue() {
        return (byte)value;
    }
    public short shortValue() {
        return (short)value;
    }
    public int intValue() {
        return value;
    }
    public long longValue() {
        return (long)value;
    }
    public float floatValue() {
        return (float)value;
    }
    public double doubleValue() {
        return (double)value;
    }
     public String toString() {
        return toString(value);
    }
    public int hashCode() {
        return value;
    }
    //判断数字相等使用基本类型int值比较，直接使用==比较Integer的是地址。
    public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
    //此处调用了类的静态方法比较两个int型数字的大小
    public int compareTo(Integer anotherInteger) {
        return compare(this.value, anotherInteger.value);
    }

    public static int compare(int x, int y) {
        return (x &amp;lt; y) ? -1 : ((x == y) ? 0 : 1);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;IntegerCache&lt;/h2&gt;
&lt;p&gt;Integer类内部有一个私有的静态内部类IntegerCache，该类缓存了一些常用的int值到缓存中，从而保证这些int可以直接获取而不用构造。最大值可以通过虚拟机参数java.lang.Integer.IntegerCache.high类配置，但是最小的为127.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private static class IntegerCache {
        static final int low = -128;//最小缓存int值
        static final int high;//最大缓存int值，默认127
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
            if (integerCacheHighPropValue != null) {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k &amp;lt; cache.length; k++)
                cache[k] = new Integer(j++);
        }

        private IntegerCache() {}
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;bitCount&lt;/h2&gt;
&lt;p&gt;Integer中的类方法：bitCount(int i),返回int数字的二进制原码中1出现的次数
如&lt;code&gt;Integer.bitCount(10)==2&lt;/code&gt;,10的二进制源码为1010,1出现2次。&lt;/p&gt;
&lt;h6&gt;原理：二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。&lt;/h6&gt;
&lt;p&gt;1.两两一组相加,并且用该对应的两位来存储这个个数：二进制中先分割为2位计算，如108=01101100=0000 0000 0000 0000 0000 0000 0110 1100，第一个2位为00，出现1的个数为0+0=00，最后4个两位为：01,10,11,00,计算后的二进制为：
0+1=01,1+0=01,1+1=10,0+0=00,即0101 1000,最后得到的二进制是：0000 0000 0000 0000 0000 0000 0101 1000&lt;/p&gt;
&lt;p&gt;2.四四一组相加，并且用该对应的四位来存储这个个数：对两两一组相加相加的结果四四一组相加，即
0000 0000 0000 0000 0000 0000 0101 1000进行四四一组相加，0101：01+01=0010，1000：10+00=0010,最后结果为：0000 0000 0000 0000 0000 0000 0010 0010&lt;/p&gt;
&lt;p&gt;3.八八一组相加，并且用该对应的八位来存储这个个数：对四四一组相加相加的结果八八一组相加，即
0000 0000 0000 0000 0000 0000 0010 0010进行八八一组相加，00100010：0010+0010=00000100最后结果为：0000 0000 0000 0000 0000 0000 0000 0100&lt;/p&gt;
&lt;p&gt;4.十六十六一组相加，并且用该对应的十六位来存储这个个数：对八八一组相加相加的结果十六十六一组相加，即0000 0000 0000 0100：0000 0000 + 0000 0100 = 0000 0000 0000 0100
最后结果为：0000 0000 0000 0000 0000 0000 0000 0100
最后相加：0000 0000 0000 0000 + 0000 0000 0000 0100 = 0000 0000 0000 0000 0000 0000 0000 0100 = 4&lt;/p&gt;
&lt;h5&gt;计算过程：&lt;/h5&gt;
&lt;p&gt;第一行：i = i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
i=0000 0000 0000 0000 0000 0000 0110 1100
0x55555555=0101 0101 0101 0101 0101 0101 0101 0101
二位二进制中:原码-高位值=1出现的个数，
（11-(11&amp;gt;&amp;gt;1)&amp;amp;01）=10=2
（10-(10&amp;gt;&amp;gt;1)&amp;amp;01）=01=1
（01-(01&amp;gt;&amp;gt;1)&amp;amp;01）=01=1
（00-(00&amp;gt;&amp;gt;1)&amp;amp;01）=00=0
i&amp;gt;&amp;gt;&amp;gt;1:原码值右移一位：01 10 11 00--&amp;gt;00 11 01 10
(i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555：原码中所有两位二进制高位值：00 01 01 00
i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555)：原码中所有两位二进制1的个数：01 01 10 00
二进制减法的规则是低位不足向高位借位，二位二进制原码-高位值，这样在做减法的时候保证了2位相减不会出现借位。&lt;/p&gt;
&lt;p&gt;第二行：i = (i &amp;amp; 0x33333333) + ((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
i=0000 0000 0000 0000 0000 0000 0101 1000
0x33333333：0011 0011 0011 0011 0011 0011 0011 0011
（i &amp;amp; 0x33333333)：4位中的低二位值：0000 0000 0000 0000 0000 0000 0001 0000
((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333)：4位中的高二位值：0000 0000 0000 0000 0000 0000 0001 0010
四位中的高二位和低二位相加为：0000 0000 0000 0000 0000 0000 0010 0010&lt;/p&gt;
&lt;p&gt;第三行：i = (i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f;
i=0000 0000 0000 0000 0000 0000 0010 0010
0x0f0f0f0f：0000 1111 0000 1111 0000 1111 0000 1111
i + (i &amp;gt;&amp;gt;&amp;gt; 4)：原码和右移四位相加，44相加，一般值无效，
0000 0000 0000 0000 0000 0000 0010 0010 +
0000 0000 0000 0000 0000 0000 0000 0010 =
0000（无） 0000（有） 0000（无） 0000（有） 0000（无） 0000（有） 0010（无） 0100（有）
(i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f：去除无效值（无效值全部变为0）：00000000 00000000 00000000 00000100&lt;/p&gt;
&lt;p&gt;第四行：i = i + (i &amp;gt;&amp;gt;&amp;gt; 8);
i = 00000000 00000000 00000000 00000100
i + (i &amp;gt;&amp;gt;&amp;gt; 8)：原码右移8位与原码相加（错8位相加）
00000000（有） 00000000（有） 00000000（有） 00000100（有）
00000000（无） 00000000（有） 00000000（有） 00000000（有）
00000000（无） 00000000（有） 00000000（无） 00000100（有）
i = i + (i &amp;gt;&amp;gt;&amp;gt; 8)： 00000000 00000000 00000000 00000100&lt;/p&gt;
&lt;p&gt;第五行：i = i + (i &amp;gt;&amp;gt;&amp;gt; 16);
i = 00000000（无） 00000000（有） 00000000（无） 00000100（有）
i + (i &amp;gt;&amp;gt;&amp;gt; 16): 原码右移16位与原码相加（错16位相加）
00000000（无） 00000000（有） 00000000（无） 00000100（有）
00000000（无） 00000000（无） 00000000（无） 00000000（有）
00000000（无） 00000000（无） 00000000（无） 00000100（有）&lt;/p&gt;
&lt;p&gt;第六行：i &amp;amp; 0x3f;
i= 00000000（无） 00000000（无） 00000000（无） 00000100（有）
0x3f:0011 0000 0000 0000 0000 0011 1111
i &amp;amp; 0x3f:最后计算的结果只有后6位二进制是有效结果：000100=4&lt;/p&gt;
&lt;h4&gt;i=1111 1111 1111 1111 1111 1111 1111 1111&lt;/h4&gt;
&lt;p&gt;第一行：i = i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
i=11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
0x55555555=01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555):10 10 10 10 10 10 10 10 &lt;/p&gt;
&lt;p&gt;第二行：i = (i &amp;amp; 0x33333333) + ((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
i=1010 1010 1010 1010
0x33333333：0011 0011 0011 0011 0011 0011 0011 0011
（i &amp;amp; 0x33333333)：0010 0010 0010 0010 0010 0010 0010 0010
((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333)：4位中的高二位值：0010 0010 0010 0010 0010 0010 0010 0010
四位中的高二位和低二位相加为：0100 0100 0100 0100 0100 0100 0100 0100 0100&lt;/p&gt;
&lt;p&gt;第三行：i = (i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f;
i=0100 0100 0100 0100 0100 0100 0100 0100 0100
0x0f0f0f0f：0000 1111 0000 1111 0000 1111 0000 1111
i + (i &amp;gt;&amp;gt;&amp;gt; 4)：原码和右移四位相加，44相加，一般值无效，
0100 0100 0100 0100 0100 0100 0100 0100 0100 +
0000 0100 0100 0100 0100 0100 0100 0100 0100 =
0000（无效） 1000 1000（无效） 1000 1000（无效） 1000 1000（无效） 1000
(i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f：去除无效值（无效值全部变为0）：
00001000 0001000 0001000 0001000&lt;/p&gt;
&lt;p&gt;第四行：i = i + (i &amp;gt;&amp;gt;&amp;gt; 8);
i=00001000 0001000 0001000 0001000
00001000（有） 00001000（有） 00001000（有） 00001000（有）
00000000（无） 00001000（有） 00001000（有） 00001000（有）
00000000（无） 00010000（有） 00010000（无） 00010000（有）
i = i + (i &amp;gt;&amp;gt;&amp;gt; 8)：00000000（无） 00010000（有） 00010000（无效） 00010000（有）&lt;/p&gt;
&lt;p&gt;第五行：i = i + (i &amp;gt;&amp;gt;&amp;gt; 16);
00000000（无） 00010000（有） 00010000（无） 00010000（有）
00000000（无） 00000000（无） 00000000（无） 00010000 （有）
00000000（无） 00010000（无） 00010000（无） 00100000 （有）&lt;/p&gt;
&lt;p&gt;第六行：i &amp;amp; 0x3f;
i=00000000（无） 00010000（无） 00010000（无） 00100000 （有）
0x3f:0011 0000 0000 0000 0000 0011 1111
i &amp;amp; 0x3f:最后计算的结果只有后6位二进制是有效结果：100000=32&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
        i = (i &amp;amp; 0x33333333) + ((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
        i = (i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f;
        i = i + (i &amp;gt;&amp;gt;&amp;gt; 8);
        i = i + (i &amp;gt;&amp;gt;&amp;gt; 16);
        return i &amp;amp; 0x3f;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;String转换成Integer&lt;/h2&gt;
&lt;p&gt;Integer的valueOf方法：如果缓存中有值，则读取缓存中的数字&lt;/p&gt;
&lt;p&gt;Integer的parseInt方法：将字符串解析成Integer&lt;/p&gt;
&lt;p&gt;Integer的decode方法： 字符串解码位数字。&lt;/p&gt;
&lt;p&gt;valueOf和parseInt的参数必须是标准数字十进制&lt;/p&gt;
&lt;p&gt;decode可以是各种形式的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(parseInt(&quot;111&quot;));
System.out.println(parseInt(&quot;111&quot;,10));
System.out.println(valueOf(&quot;111&quot;));
System.out.println(valueOf(&quot;111&quot;,10));
System.out.println(valueOf(10));
System.out.println(Integer.decode(&quot;100&quot;));//十进制
System.out.println(Integer.decode(&quot;0xa&quot;));//十六进制
System.out.println(Integer.decode(&quot;0Xa&quot;));//十六进制
System.out.println(Integer.decode(&quot;#a&quot;));//十六进制
System.out.println(Integer.decode(&quot;010&quot;));//八进制
System.out.println(Integer.decode(&quot;+100&quot;));//正数
System.out.println(Integer.decode(&quot;-100&quot;));//负数&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static int parseInt(String s) throws NumberFormatException {
        return parseInt(s,10);
    }

    public static int parseInt(String s, int radix)
                throws NumberFormatException {
        /*
         * WARNING: This method may be invoked early during VM initialization
         * before IntegerCache is initialized. Care must be taken to not use
         * the valueOf method.
         */
        //s不能为空，进制数在Character.MIN_RADIX（2）和Character.MAX_RADIX（36）之间
        if (s == null) {
            throw new NumberFormatException(&quot;null&quot;);
        }
        if (radix &amp;lt; Character.MIN_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; less than Character.MIN_RADIX&quot;);
        }
        if (radix &amp;gt; Character.MAX_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; greater than Character.MAX_RADIX&quot;);
        }

        int result = 0;
        boolean negative = false;//符号
        int i = 0;//偏移值
        int len = s.length();
        int limit = -Integer.MAX_VALUE;
        int multmin;
        int digit;
        if (len &amp;gt; 0) {
            char firstChar = s.charAt(0);
            if (firstChar &amp;lt; '0') { // Possible leading &quot;+&quot; or &quot;-&quot;
                if (firstChar == '-') {
                    negative = true;
                    limit = Integer.MIN_VALUE;
                } else if (firstChar != '+')
                    throw NumberFormatException.forInputString(s);
                if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot;
                    throw NumberFormatException.forInputString(s);
                i++;
            }
            multmin = limit / radix;
            //一个字符一个字符累加
            while (i &amp;lt; len) {
                // Accumulating negatively avoids surprises near MAX_VALUE
                digit = Character.digit(s.charAt(i++),radix);
                if (digit &amp;lt; 0) {
                    throw NumberFormatException.forInputString(s);
                }
                if (result &amp;lt; multmin) {
                    throw NumberFormatException.forInputString(s);
                }
                result *= radix;
                if (result &amp;lt; limit + digit) {
                    throw NumberFormatException.forInputString(s);
                }
                result -= digit;//通过负数减法计算加法
            }
        } else {
            throw NumberFormatException.forInputString(s);
        }
        return negative ? result : -result;
    }

    public static Integer valueOf(String s, int radix) throws NumberFormatException {
        return Integer.valueOf(parseInt(s,radix));
    }

    public static Integer valueOf(String s) throws NumberFormatException {
        return Integer.valueOf(parseInt(s, 10));
    }

    public static Integer valueOf(int i) {
        assert IntegerCache.high &amp;gt;= 127;
        //判断数字是否有缓存
        if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }

    public static Integer decode(String nm) throws NumberFormatException {
        int radix = 10;//进制数
        int index = 0;//偏移数
        boolean negative = false;//是否有符号
        Integer result;//最后结果

        if (nm.length() == 0)
            throw new NumberFormatException(&quot;Zero length string&quot;);
        char firstChar = nm.charAt(0);
        // Handle sign, if present
        if (firstChar == '-') {
            negative = true;//负数
            index++;
        } else if (firstChar == '+')
            index++;

        // Handle radix specifier, if present
        if (nm.startsWith(&quot;0x&quot;, index) || nm.startsWith(&quot;0X&quot;, index)) {
            index += 2;
            radix = 16;//16进制
        }
        else if (nm.startsWith(&quot;#&quot;, index)) {
            index ++;
            radix = 16;//16进制
        }
        else if (nm.startsWith(&quot;0&quot;, index) &amp;amp;&amp;amp; nm.length() &amp;gt; 1 + index) {
            index ++;
            radix = 8;//8进制
        }

        if (nm.startsWith(&quot;-&quot;, index) || nm.startsWith(&quot;+&quot;, index))
            throw new NumberFormatException(&quot;Sign character in wrong position&quot;);

        try {
            result = Integer.valueOf(nm.substring(index), radix);//字符串转换成Integer
            result = negative ? Integer.valueOf(-result.intValue()) : result;//判断正负值
        } catch (NumberFormatException e) {
            // If number is Integer.MIN_VALUE, we'll end up here. The next line
            // handles this case, and causes any genuine format error to be
            // rethrown.
            String constant = negative ? (&quot;-&quot; + nm.substring(index))
                                       : nm.substring(index);
            result = Integer.valueOf(constant, radix);
        }
        return result;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Integer转换成String&lt;/h2&gt;
&lt;p&gt;toString(int i, int radix) 转换成指定进制的字符串&lt;/p&gt;
&lt;p&gt;toString(int i) 转换成十进制的字符串&lt;/p&gt;
&lt;p&gt;toHexString(int i) 转换成十六进制的字符串&lt;/p&gt;
&lt;p&gt;toOctalString(int i) 转换成八进制的字符串&lt;/p&gt;
&lt;p&gt;toBinaryString(int i) 转换成二进制的字符串&lt;/p&gt;
&lt;p&gt;toUnsignedString(int i, int shift) &lt;/p&gt;
&lt;p&gt;int转2进制：&lt;code&gt;toUnsignedString（i,1）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;int转8进制：&lt;code&gt;toUnsignedString（i,3）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;int转16进制：&lt;code&gt;toUnsignedString（i,4）&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static String toString(int i, int radix) {
        if (radix &amp;lt; Character.MIN_RADIX || radix &amp;gt; Character.MAX_RADIX)
            radix = 10;
        /* Use the faster version */
        if (radix == 10) {
            return toString(i);
        }
        char buf[] = new char[33];
        boolean negative = (i &amp;lt; 0);
        int charPos = 32;
        if (!negative) {
            i = -i;
        }
        while (i &amp;lt;= -radix) {
            buf[charPos--] = digits[-(i % radix)];
            i = i / radix;
        }
        buf[charPos] = digits[-i];

        if (negative) {
            buf[--charPos] = '-';
        }
        return new String(buf, charPos, (33 - charPos));
    }

    public static String toString(int i) {
        if (i == Integer.MIN_VALUE)
            return &quot;-2147483648&quot;;
        int size = (i &amp;lt; 0) ? stringSize(-i) + 1 : stringSize(i);
        char[] buf = new char[size];
        getChars(i, size, buf);
        return new String(buf, true);
    }

    public static String toHexString(int i) {
        return toUnsignedString(i, 4);
    }
    public static String toOctalString(int i) {
        return toUnsignedString(i, 3);
    }
     public static String toBinaryString(int i) {
        return toUnsignedString(i, 1);
    }
    private static String toUnsignedString(int i, int shift) {
        char[] buf = new char[32];//int型最大为32位
        int charPos = 32;//数组下标位置
        int radix = 1 &amp;lt;&amp;lt; shift;//将0001左移，shift为偏移位，如16进制则偏移4位计算，8进制偏移3位计算
        int mask = radix - 1;//计算元数据的计算为，如果转16进制取后4位计算，mask为1111，与的结果为取后四位为有效位
        do {
            buf[--charPos] = digits[i &amp;amp; mask];
            i &amp;gt;&amp;gt;&amp;gt;= shift;//通过右移将计算过的位数舍弃掉，如10010100的后四位计算过了，则右移4位变成1001
        } while (i != 0);
        //将char转换成字符串，并舍弃前面的0
        return new String(buf, charPos, (32 - charPos));
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Interget.getChars:将数字转换成字符数组，第一个参数为要转换的数字，第二个参数为字符数组的长度，第三个参数为字符数组的引用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;q = i / 100; r = i - ((q &amp;lt;&amp;lt; 6) + (q &amp;lt;&amp;lt; 5) + (q &amp;lt;&amp;lt; 2))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此处计算相当于r = i - (q * 100);即求i除以100之后的余数，i%100&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(int * 52429) &amp;gt;&amp;gt;&amp;gt; 19 === (int * 52429)/524288 === int / 10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i - (q * (64 + 32 + 4)) 
==&amp;gt; i - (q * (64 + 32 + 4)) 
==&amp;gt; i - (q * 64 + q * 32 + q * 4)) 
==&amp;gt; i - (q &amp;lt;&amp;lt; 6 + q &amp;lt;&amp;lt; 5 + q &amp;lt;&amp;lt; 2))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;q = (i * 52429) &amp;gt;&amp;gt;&amp;gt; (16+3); r = i - ((q &amp;lt;&amp;lt; 3) + (q &amp;lt;&amp;lt; 1));  // r = i-(q*10)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此处计算相当于r = i-(q*10);即求i除以10之后的余数，i%10&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //该方法用于将数字转换成字符数组
    static void getChars(int i, int index, char[] buf) {
        int q, r;
        int charPos = index;
        char sign = 0;

        if (i &amp;lt; 0) {
            sign = '-';
            i = -i;
        }

        // Generate two digits per iteration
        //数字的二进制长度大于16位则每2位转换一次字符，
        while (i &amp;gt;= 65536) {
            q = i / 100; //q为数字去掉右边两位之后的数值
            // really: r = i - (q * 100);
            r = i - ((q &amp;lt;&amp;lt; 6) + (q &amp;lt;&amp;lt; 5) + (q &amp;lt;&amp;lt; 2)); //余数
            i = q;
            buf [--charPos] = DigitOnes[r];
            buf [--charPos] = DigitTens[r];
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i &amp;lt;= 65536, i);
        for (;;) {
            q = (i * 52429) &amp;gt;&amp;gt;&amp;gt; (16+3);
            r = i - ((q &amp;lt;&amp;lt; 3) + (q &amp;lt;&amp;lt; 1));  // r = i-(q*10)
            buf [--charPos] = digits [r];
            i = q;
            if (i == 0) break;
        }
        if (sign != 0) {
            buf [--charPos] = sign;
        }
    }
    //字符数组
    final static char[] digits = {
            '0' , '1' , '2' , '3' , '4' , '5' ,
            '6' , '7' , '8' , '9' , 'a' , 'b' ,
            'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,
            'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
            'o' , 'p' , 'q' , 'r' , 's' , 't' ,
            'u' , 'v' , 'w' , 'x' , 'y' , 'z'
        };
   //数字字符数组。用于通过下标获取数据，该数字获取2位数中十位数值
   //如获取23十位数字为：DigitTens[23]=2
    final static char [] DigitTens = {
            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
            } ;
    //数字字符数组。用于通过下标获取数据，该数字获取2位数中个位数值
    //如获取23个位数字为：DigitOnes[23]=3
    final static char [] DigitOnes = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        } ;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Integer  highestOneBit和lowestOneBit
数字二进制中1出现的位置（最高位和最低位）
如：20=10100，
最高位：10000 = 16
最低位：100 = 4&lt;/p&gt;
&lt;p&gt;按位与： &amp;amp; ：真真为真，其余为假：遇0为0
按位或： | ：假假为假，其余为真：遇1为1
按位非： ~ ：取反码
按位异或： ^ ：真假为真，其余为假：不同为1&lt;/p&gt;
&lt;p&gt;highestOneBitd的原理&lt;/p&gt;
&lt;p&gt;将二进制数的所有位数都转换为1，
然后用原数减去全为一的数右移一位后的数。
如10010 -- 11111 -- 11111 - 1111 = 10000&lt;/p&gt;
&lt;p&gt;i |= (i &amp;gt;&amp;gt;  1);&lt;/p&gt;
&lt;p&gt;i = 10100 | 10100 &amp;gt;&amp;gt; 1 = 10100 | 1010 = 11110
i = 11110 | 11110 &amp;gt;&amp;gt; 2 = 11110 | 111 = 11111
i = 11111 | 11111 &amp;gt;&amp;gt; 4 = 11111 | 1 = 11111
i = 11111 | 11111 &amp;gt;&amp;gt; 8 = 11111 | 0 = 11111
i = 11111 | 11111 &amp;gt;&amp;gt; 16 = 11111 | 0 = 11111
i = 11111 - (11111 &amp;gt;&amp;gt;&amp;gt; 1) = 11111 - 1111 = 10000&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static int highestOneBit(int i) {
        // HD, Figure 3-1
        i |= (i &amp;gt;&amp;gt;  1);//
        i |= (i &amp;gt;&amp;gt;  2);
        i |= (i &amp;gt;&amp;gt;  4);
        i |= (i &amp;gt;&amp;gt;  8);
        i |= (i &amp;gt;&amp;gt; 16);
        return i - (i &amp;gt;&amp;gt;&amp;gt; 1);
    }

    public static int lowestOneBit(int i) {
        // HD, Section 2-1
        return i &amp;amp; -i;
    }&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/java-src-Integer.html</link>
            <guid isPermaLink="true">//blog/java-src-Integer.html</guid>
                                               <category>Java</category>
                                    </item>
                <item>
            <title>lua_code_cache</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-24
title: lua_code_cache
tags: lua
category: Lua
status: publish
summary: 开启或者关闭lua代码缓存，在*_by_lua_file（如set_by_lua_file和content_by_lua_file）指令和Lua模块中生效
--&gt;
&lt;h2&gt;lua_code_cache&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_code_cache on | off&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default:&lt;/strong&gt; &lt;em&gt;lua_code_cache on&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;http, server, location, location if&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Enables or disables the Lua code cache for Lua code in &lt;code&gt;*_by_lua_file&lt;/code&gt; directives (like &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt; and
&lt;a href=&quot;#content_by_lua_file)&quot;&gt;content_by_lua_file&lt;/a&gt; and Lua modules.&lt;/p&gt;
&lt;p&gt;When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the &lt;code&gt;0.9.3&lt;/code&gt; release. So the Lua files referenced in &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt;,
&lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;, &lt;a href=&quot;#access_by_lua_file&quot;&gt;access_by_lua_file&lt;/a&gt;,
and etc will not be cached
and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.&lt;/p&gt;
&lt;p&gt;Please note however, that Lua code written inlined within nginx.conf
such as those specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;,
&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, and &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; will not be updated when you edit the inlined Lua code in your &lt;code&gt;nginx.conf&lt;/code&gt; file because only the Nginx config file parser can correctly parse the &lt;code&gt;nginx.conf&lt;/code&gt;
file and the only way is to reload the config file
by sending a &lt;code&gt;HUP&lt;/code&gt; signal or just to restart Nginx.&lt;/p&gt;
&lt;p&gt;Even when the code cache is enabled, Lua files which are loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;loadfile&lt;/code&gt;
in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;
or &lt;a href=&quot;#init-by_lua_file&quot;&gt;init_by_lua_file&lt;/a&gt; directives to load all such files or just make these Lua files true Lua modules
and load them via &lt;code&gt;require&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The ngx_lua module does not support the &lt;code&gt;stat&lt;/code&gt; mode available with the
Apache &lt;code&gt;mod_lua&lt;/code&gt; module (yet).&lt;/p&gt;
&lt;p&gt;Disabling the Lua code cache is strongly
discouraged for production use and should only be used during
development as it has a significant negative impact on overall performance. For example, the performance a &amp;quot;hello world&amp;quot; Lua example can drop by an order of magnitude after disabling the Lua code cache.&lt;/p&gt;
&lt;h2&gt;中文&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt; &lt;em&gt;lua_code_cache on | off&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt; &lt;em&gt;lua_code_cache on&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文:&lt;/strong&gt; &lt;em&gt;http, server, location, location if&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;开启或者关闭lua代码缓存，在*_by_lua_file（如set_by_lua_file和content_by_lua_file）指令和Lua模块中生效。
从0.9.3稳定版开始，当lua_code_cache指令关闭时，所以被ngx_lua解析的请求都将运行在单独的虚拟机实例中。因此，被set_by_lua_file，content_by_lua_file，access_by_lua_file等等引用的Lua文件将不会被缓存，所有lua模块在被使用时都将会被重新读取加载，在这里，开发人员可以编辑刷新即可显示，不需要重启nginx服务。&lt;/p&gt;
&lt;p&gt;然而,请注意,当你编辑lua脚本时，那些被写在nginx.conf内部的lua脚本（如set_by_lua，content_by_lua，access_by_lua和rewrite_by_lua引用的脚本）将不会被重新加载，因为只有Nginx配置文件解析器能正确解析nginx.conf配置文件，而且能够重新加载配置文件的方式只有发送HUP信号量和重启Nginx。&lt;/p&gt;
&lt;p&gt;甚至当lua代码缓存被开启的时候，这些在*_by_lua_file中通过dofile或者loadfile被加载的lua文件也不能被缓存（除非你自己去缓存他）。通常你能用init_by_lua或者init-by_lua_file指令加载所以这样的文件，或者编译这些lua文件到lua模块通过require加载。&lt;/p&gt;
&lt;p&gt;ngx_lua模块任然不支持stat模式。&lt;/p&gt;
&lt;p&gt;强烈的不建议在生成环境中关闭lua代码缓存，仅仅在开发期间关闭，因为关闭缓存对整体性能有很大的负面影响。例如在一个hello world的lua示例中关闭代码缓存，性能将下降一个数量级。&lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/lua-directive-lua_code_cache.html</link>
            <guid isPermaLink="true">//blog/lua-directive-lua_code_cache.html</guid>
                                               <category>Lua</category>
                                    </item>
                <item>
            <title>lua_use_default_type</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-24
title: lua_use_default_type
tags: lua
category: Lua
status: publish
summary: 指定是否使用MIME类型（default_type指令指定的类型）作为Content-Type响应头信息。如果你不想使用这个默认的Content-Type响应头信息给你的Lua请求去处理，则将这个指令设置为关闭状态&gt;（off）。
--&gt;
&lt;h2&gt;lua_use_default_type&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_use_default_type on | off&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default:&lt;/strong&gt; &lt;em&gt;lua_use_default_type on&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;http, server, location, location if&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Specifies whether to use the MIME type specified by the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt; directive for the default value of the &lt;code&gt;Content-Type&lt;/code&gt; response header. If you do not want a default &lt;code&gt;Content-Type&lt;/code&gt; response header for your Lua request handlers, then turn this directive off.&lt;/p&gt;
&lt;p&gt;This directive is turned on by default.&lt;/p&gt;
&lt;p&gt;This directive was first introduced in the &lt;code&gt;v0.9.1&lt;/code&gt; release.&lt;/p&gt;
&lt;h2&gt;中文&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法 :&lt;/strong&gt; &lt;em&gt;lua_use_default_type on | off&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt; &lt;em&gt;lua_use_default_type on&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文:&lt;/strong&gt; &lt;em&gt;http, server, location, location if&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;指定是否使用MIME类型（default_type指令指定的类型）作为Content-Type响应头信息。如果你不想使用这个默认的Content-Type响应头信息给你的Lua请求去处理，则将这个指令设置为关闭状态（off）。&lt;/p&gt;
&lt;p&gt;这个指令默认是开启状态（on）&lt;/p&gt;
&lt;p&gt;这个指令第一次出现是在 v0.9.1 稳定版中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wngn123@163.com on 206-07-12&lt;/code&gt;&lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/lua-directive-lua_use_default_type.html</link>
            <guid isPermaLink="true">//blog/lua-directive-lua_use_default_type.html</guid>
                                               <category>Lua</category>
                                    </item>
                <item>
            <title>lua_regex_cache_max_entries</title>
            <description>
            &lt;!--
author: wngn123
head: head.png
date: 2016-08-24
title: lua_regex_cache_max_entries
tags: lua
category: Lua
status: publish
summary: 指定在worker进程级别编译的正则表达式缓存结果的最大数量
--&gt;
&lt;h2&gt;lua_regex_cache_max_entries&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default:&lt;/strong&gt; &lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Specifies the maximum number of entries allowed in the worker process level compiled regex cache.&lt;/p&gt;
&lt;p&gt;The regular expressions used in &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;, &lt;a href=&quot;#ngxregmatch&quot;&gt;ngx.re.gmatch&lt;/a&gt;, &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;, and &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub&lt;/a&gt; will be cached within this cache if the regex option &lt;code&gt;o&lt;/code&gt; (i.e., compile-once flag) is specified.&lt;/p&gt;
&lt;p&gt;The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the &lt;code&gt;o&lt;/code&gt; option was not specified) and there will be one, and only one, warning in the &lt;code&gt;error.log&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not activate the &lt;code&gt;o&lt;/code&gt; option for regular expressions (and/or &lt;code&gt;replace&lt;/code&gt; string arguments for &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt; and &lt;a href=&quot;#ngxregsub)&quot;&gt;ngx.re.gsub&lt;/a&gt; that are generated &lt;em&gt;on the fly&lt;/em&gt; and give rise to infinite variations to avoid hitting the specified limit.&lt;/p&gt;
&lt;h2&gt;中文&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt; &lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt; &lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;指定在worker进程级别编译的正则表达式缓存结果的最大数量。&lt;/p&gt;
&lt;p&gt;当正则选项o被指定的时候，ngx.re.match，ngx.re.gmatch，ngx.re.sub，ngx.re.gsub使用的正则表达式会被缓存在缓存中。&lt;/p&gt;
&lt;p&gt;缓存数量的最大值默认是1024，如果数量达到最大值限定值，新的正则表达式将不会被缓存（就像o选项没有指定一样），但是会写一条，仅仅一条警告日志到error.log文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意不要激活那些会很快的产生和引起无数的变化的正则表达式的o选项（或者为ngx.re.sub和ngx.re.gsub替换字符串参数），以避免达到指定的限制。&lt;/p&gt;
&lt;h4&gt;扩展&lt;/h4&gt;
&lt;p&gt;o 选项参数用于提高性能，指明该参数之后，被编译的 Pattern 将会在 worker 进程中缓存，并且被当前 worker 进程的每次请求所共享。 Pattern 缓存的上限值通过 lua_regex_cache_max_entries 来修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# nginx.conf
location /test {
    content_by_lua '
        local regex = [[\\d+]]

        -- 参数&quot;o&quot;是开启缓存必须的
        local m = ngx.re.match(&quot;hello, 1234&quot;, regex, &quot;o&quot;)  
        if m then
            ngx.say(m[0])
        else
            ngx.say(&quot;not matched!&quot;)
        end
    ';
}
# 在网址中输入&quot;yourURL/test&quot;，即会在网页中显示 1234 。&lt;/code&gt;&lt;/pre&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/lua-directive-lua_regex_cache_max_entries.html</link>
            <guid isPermaLink="true">//blog/lua-directive-lua_regex_cache_max_entries.html</guid>
                                               <category>Lua</category>
                                    </item>
                <item>
            <title>欢迎使用GitBlog</title>
            <description>
            &lt;!--
author: wangn123
head: head.png
date: 2015-07-31
title: 欢迎使用GitBlog
tags: git blog
category: GitBlog
status: publish
summary: GitBlog是一个简单易用的Markdown博客系统，它不需要数据库，没有管理后台功能，更新博客只需要添加你写好的Markdown文件即可。
--&gt;
&lt;h2&gt;一. 简介&lt;/h2&gt;
&lt;p&gt;GitBlog是一个简单易用的Markdown博客系统，它不需要数据库，没有管理后台功能，更新博客只需要添加你写好的Markdown文件即可。它摆脱了在线编辑器排版困难，无法实时预览的缺点，一切都交给Markdown来完成，一篇博客就是一个Markdown文件。同时也支持评论，代码高亮，数学公式，页面PV统计等常用功能。GitBlog提供了不同的主题样式，你可以根据自己的喜好配置，如果你想自己制作博客主题，也是非常容易的。GitBlog还支持整站静态导出，你完全可以导出整站静态网页部署到Github Pages。&lt;/p&gt;
&lt;h2&gt;二. 功能特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用Markdown  &lt;/li&gt;
&lt;li&gt;评论框  &lt;/li&gt;
&lt;li&gt;代码高亮  &lt;/li&gt;
&lt;li&gt;PV统计  &lt;/li&gt;
&lt;li&gt;Latex数学公式  &lt;/li&gt;
&lt;li&gt;自制主题  &lt;/li&gt;
&lt;li&gt;响应式  &lt;/li&gt;
&lt;li&gt;全站静态导出  &lt;/li&gt;
&lt;li&gt;良好的SEO  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;三. GitBlog优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;无需数据库，系统更轻量，移植更方便  &lt;/li&gt;
&lt;li&gt;使用Markdown编写，摆脱后台编辑排版困难，无法实时预览的缺点  &lt;/li&gt;
&lt;li&gt;可全站静态导出  &lt;/li&gt;
&lt;li&gt;配置灵活，可自由开关某些功能  &lt;/li&gt;
&lt;li&gt;多主题支持，可自制主题  &lt;/li&gt;
&lt;li&gt;博客，分类，标签，归档  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;四. 环境要求&lt;/h2&gt;
&lt;p&gt;PHP 5.2.4+ &lt;/p&gt;
&lt;p&gt;不支持PHP7&lt;/p&gt;
&lt;h2&gt;五. 安装步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下载GitBlog源代码  &lt;/li&gt;
&lt;li&gt;解压上传到你的PHP网站根目录  &lt;/li&gt;
&lt;li&gt;打开浏览器，访问网站首页  &lt;/li&gt;
&lt;li&gt;上传Markdown文件到&lt;code&gt;posts&lt;/code&gt;文件夹  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;六. 详细说明&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/install.html&quot;&gt;1. 安装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/struct.html&quot;&gt;2. 目录结构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/config.html&quot;&gt;3. 配置说明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/gitblog/edit.html&quot;&gt;4. 编写博客&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/other-func.html&quot;&gt;5. 评论，订阅，统计等&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/cache.html&quot;&gt;6. 缓存机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/export.html&quot;&gt;7. 全站静态导出&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/theme.html&quot;&gt;8. 主题制作&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/nginx.html&quot;&gt;9. 在Nginx上运行GitBlog&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/apache.html&quot;&gt;10. 在Apache上运行GitBlog&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/sae.html&quot;&gt;11. 在SAE上运行GitBlog&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/github-pages.html&quot;&gt;12. 使用GitBlog和Github Pages搭建博客&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/update.html&quot;&gt;13. Gitblog升级&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gitblogdoc.gitblog.cn/blog/gitblog/wordpress.html&quot;&gt;14. 从wordpress导入&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;七. 问题及bug反馈&lt;/h2&gt;
&lt;p&gt;如果在实际使用过程中对GitBlog有新的功能需求，或者在使用GitBlog的过程中发现了Bug，欢迎反馈给我。可以直接在Github上提交，也可以发邮件至&lt;code&gt;164068300[AT]qq.com&lt;/code&gt;与我取得联系，我将及时回复。如果你自己制作了漂亮好用的主题，也非常欢迎你提交给我，我会在这里展示你的主题链接。如果你正在使用GitBlog，也可以告诉我，我将也会在这里列出使用者名单。如果你想和其他GitBlog使用者讨论交流，欢迎加入QQ群&lt;code&gt;84692078&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;八. 使用者列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hiweeds.net&quot;&gt;Weeds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xiaochengzi.sinaapp.com&quot;&gt;橙子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jockchou.gitblog.cn&quot;&gt;jockchou&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gitblogdoc.sinaapp.com&quot;&gt;GitBlog Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zxy.link&quot;&gt;zxy&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;九. 感谢&lt;/h2&gt;
&lt;p&gt;GitBlog的成长需要喜欢Markdown，喜欢写博客的各位亲们支持！感谢你们使用GitBlog，感激你们对Gitblog的良好建议与Bug反馈。&lt;/p&gt;
&lt;p&gt;QQ群：&lt;code&gt;84692078&lt;/code&gt;&lt;br /&gt;
作者邮箱：&lt;code&gt;164068300[AT]qq.com&lt;/code&gt;    &lt;/p&gt;            </description>
            <pubDate>2016-08-31 15:50:24</pubDate>
            <link>//blog/gitblog-welcome.html</link>
            <guid isPermaLink="true">//blog/gitblog-welcome.html</guid>
                                               <category>GitBlog</category>
                                    </item>
            </channel>
</rss>